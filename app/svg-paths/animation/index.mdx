# Animating Paths

We'll finish off by talking about how to animate SVG paths. SVG path animations generally fall into one of three buckets:

- Animating path _length_;
- Animating _along_ a path; and,
- _Morphing_ a path into another path.

Let's take a look at how you might implement all three kinds using vanilla HTML, CSS, and JavaScript.

---

## Animating Path Length

It's not super straightforward to animate the length of a path. CSS doesn't have a `path-length` property after all, so you can't use `animate` or `transition` to animate the path length.

Most path length animations don't actually animate a path. Instead, these animations create the _illusion_ of a path being drawn by using the `stroke-dashoffset` and `stroke-dasharray` properties.

---

The `stroke-dasharray` property is typically used to create dashed lines. Its most general form takes two numbers: the length of the dash and the length of the gap between dashes.

For example, the following code would create a dashed line with dashes of length 10 and gaps of length 5.

```css
.path {
  stroke-dasharray: 10 5;
}
```

You can use a single number if you want both the dashes and gaps to be the same width. Here, both the dashes and the gaps have length 5.

```css
.path {
  stroke-dasharray: 5;
}
```

---

The `stroke-dashoffset` property is used to offset the start of the dash pattern. For example, the following code would offset the start of the dash pattern by 5.

```css
.path {
  stroke-dasharray: 5;
  stroke-dashoffset: 5;
}
```

By animating `stroke-dashoffset`, you get this effect where the squiggly lines move about.

---

Now what if we make the dashes so big that it covers the entire path? Well, we get a solid line:

```css
.path {
  stroke-dasharray: 1000;
}
```

---

And if we offset the dash by the length of the path, we end up with an invisible path:

```css
.path {
  stroke-dasharray: 1000;
  stroke-dashoffset: 1000;
}
```

---

By animating the offset back to 0, we get the illusion of a path being drawn!

```css
@keyframes draw {
  to {
    stroke-dashoffset: 0;
  }
}

.path {
  stroke-dasharray: 1000;
  stroke-dashoffset: 1000;
  animation: draw 3s linear forwards;
}
```

---

If we use an arbitrarily large number for the `stroke-dasharray`, we might find that the animation feels different for paths of varying lengths. This is because the animation starts from the value we set (in this case, 1000) instead of the real length of the path.

There are two ways to fix this.

First, using the `getTotalLength` method on the path element to get the real length of the path and setting that length via CSS variables:

```css
.path {
  stroke-dasharray: var(--length);
  stroke-dashoffset: var(--length);
  animation: draw 3s linear forwards;
}

@keyframes draw {
  to {
    stroke-dashoffset: 0;
  }
}
```

```js
const el = document.getElementById("path");
const length = el.getTotalLength();
el.style.setProperty("--length", length);
```

---

Alternatively, explicitly set the path's `pathLength` property to a fixed value:

```html
<path d="..." pathLength="1" />
```

Explicitly setting `pathLength` changes the "coordinate space" of the path, which means the `stroke-dasharray` and `stroke-dashoffset` properties will be relative to the path length instead of the wrapping SVG.

This lets you write the animation like so:

```css
.path {
  stroke-dasharray: 1;
  stroke-dashoffset: 1;
  animation: draw 3s linear forwards;
}

@keyframes draw {
  to {
    stroke-dashoffset: 0;
  }
}
```

Note that setting the path length affects _all_ calculations that depend on the path length, not just `stroke-dasharray` and `stroke-dashoffset`. This might mean you have to change your path's styles to account for the new coordinate space.

---

The choice is ultimately up to you:

- The `.getTotalLength()` approach lets you keep all your styles but requires JavaScript to work;
- The `pathLength` approach lets your animation work without JavaScript but might require changes to your path's styles.

---

## Animating Along a Path

---

## Morphing Paths
