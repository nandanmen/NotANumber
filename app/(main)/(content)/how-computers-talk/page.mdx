It's really easy to overlook the way the internet works. In JavaScript, we can make software that talks to other computers on the internet simply using a `fetch` call:

```js
fetch("https://nan.fyi")
  .then((response) => response.text())
  .then((html) => console.log(html)); // html of this web page!
```

But what's really happening under the hood when we do that? Let's find out!

---

## Domain Name Resolution

For starters, computers don't actually use human-readable names like `nan.fyi` or `google.com` to refer to websites. Instead, they use a sequence of numbers called an **IP address**.

Before your computer can connect to a website, it first has to _convert_ the domain name into an IP address. `google.com`, for example, corresponds to the IP address `142.250.73.110`.

<Callout>

Try entering `142.250.73.110` into your browser's address bar. You'll end up in the Google home page!

</Callout>

This conversion process is called **domain name resolution** and it's handled by a system called, rather appropriately, the **Domain Name System** (DNS for short).

---

### The DNS Lookup Process

The DNS lookup process effecively boils down to this JavaScript code:

```js
const ipAddresses = {
  "google.com": "142.250.73.110",
  "nan.fyi": "127.0.0.1",
  // other domain names and their corresponding IP addresses...
};
const ipAddress = ipAddresses["google.com"];
console.log(ipAddress); // 142.250.73.110
```

Seems pretty straightforward! And it would be, if it weren't for the fact that there are millions of domains and tens of millions of computers looking up IP addresses _every second_.

This level of scale doesn't fit in a single server. So:

<ProblemStatement>

How do we organize our table to handle _tens of millions_ of requests per second?

</ProblemStatement>

---

<ScrollGroup>

<ScrollGroupSection>

One approach would be to **divide up the domain names into smaller groups, and have dedicated servers for each group**. Thankfully, there's a pretty clear way to group domains: their _suffixes_.

For example, `google.com` and `youtube.com` both end with `.com`, so they can be grouped together. Similarly, `nan.fyi` and `example.fyi` both end with `.fyi`, so they can be grouped together too.

Each group of servers now have a much smaller table to work with!

</ScrollGroupSection>

<ScrollGroupSection>

This brings another problem though:

<ProblemStatement>

How does our computer know _where_ the servers for each suffix are?

</ProblemStatement>

Not only are there hundreds of possible suffixes, the list of suffixes and the IP addresses of the servers handling each suffix are constantly changing too. Imagine needing to update every computer on the internet every time the list of suffixes or IP addresses changes!

One way to fix this is to have an unchanging set of **root servers** that _point_ to the servers handling each suffix. With this, our computers only need to know about the root servers, and the root servers will know where to find the servers for each suffix.

</ScrollGroupSection>

</ScrollGroup>

---

Putting everything together, we get our final lookup algorithm:

1. Using the suffix of the domain, ask the root servers for the IP address of the group handling that suffix;
2. Using the IP address of the group, ask the group's servers for the IP address of the domain.

```
dns visual
```

---

<Aside label="Resolvers and Authoritative Servers">

There are two additional layers to the DNS lookup process that I omitted for simplicity: **DNS resolvers** and **authoritative servers**.

**A DNS resolver is a server dedicated to performing the DNS lookup process**. In practice, DNS lookup isn't something your computer does on its own; instead, it asks a DNS resolver to do it for them.

In other words, your computer doesn't keep the IP addresses of the root servers—only the address of the DNS resolver it should ask. In MacOS, you can check the address of your DNS resolver by running `scutil --dns`:

```bash
~ scutil --dns
DNS configuration

resolver #1
  nameserver[0] : 2001:568:ff09:10c::67
  nameserver[1] : 2001:568:ff09:10a::116
  nameserver[2] : 192.168.1.254
  if_index : 15 (en1)
  flags    : Request A records, Request AAAA records
  reach    : 0x00000002 (Reachable)

...
```

Another layer is the **authoritative server**. In practice, the "suffix servers" don't store the IP addresses of the domains they're responsible for; instead, they store the IP address of the authoritative server for that domain.

The authoritative server keeps what's called the domain's **zone file**, which contains the IP address of the domain, the subdomains, and other information about the domain.

This additional layer of indirection exists because there's more to DNS than just the IP address of a domain. Email, for example, requires a dedicated DNS record (called an MX record) to be set so that servers know where to send emails to.

</Aside>

---

## Routing

Great! At this point, we've converted the domain name into an IP address. Now how do we get data from our computer to that IP address?

---

<ScrollGroup>

<ScrollGroupSection>

### A Little Internet

Let's say you have a network of four computers that you want to connect to each other. One way to do this is to physically connect each computer—either through cables or a wireless technology of your choosing—and have every computer save the IP address of every other computer in the network.

Then, when a computer wants to send data to another computer, it can lookup the IP address of the other computer and send it along the physical connection.

```
send button
```

</ScrollGroupSection>

<ScrollGroupSection>

This is... fine, at least until you add a fifth computer to the mix:

```
add button
```

Now you have to update the previous four computers in the network to include the IP address of the new computer. If we add a sixth, we have to update all five computers; a 7th, all six, and so on.

As you might imagine, this quickly becomes impractical!

</ScrollGroupSection>

<ScrollGroupSection>

One way to fix this is to have a dedicated central computer whose sole purpose is to _connect_ the computers in the network to each other. In this setup, the computers only need to be physically connected to the central computer.

When a computer wants to send data to another, it'll send it to the central computer with the destination IP address. Since this central computer knows all of the IP addresses in the network, it can correctly _route_ the data to its destination.

```
send button
```

We'll call this central computer a **router** because, er, it routes.

</ScrollGroupSection>

<ScrollGroupSection>

Let's introduce another network to the mix.

Here, we have two networks, Network 1 and Network 2, each with four connected computers. The routers of the two networks are physically connected to each other.

With this new network, we'll need to update the hash tables in each router to allow data to be sent to computers in the other network. One option is to simply **add the IP addresses of the computers in the other network to the hash table.**

</ScrollGroupSection>

<ScrollGroupSection>

This works, but doesn't really make sense—the router in the other network already knows the IP addresses of their computers, so why should we duplicate?

What we can do instead is to change our IP address format to **include the number of the network the IP address belongs to**:

```
1.1 -> Network 1, Computer 1
2.3 -> Network 2, Computer 3
```

Now, we can change the logic in the router to check the _prefix_ first. If the destination IP address starts with "1", it's in Network 1; if it starts with "2", it's in Network 2.

</ScrollGroupSection>

<ScrollGroupSection>

In this setup, if computer `1.1` wants to send data to computer `2.3`, it will:

1. Send the data to the router with the destination IP address `2.3`;
2. The router sees the IP address starts with "2", so it sends it to the router in Network 2;
3. The router in Network 2 will see the destination is computer `2.3`, and sends it to the computer.

```
send button
```

</ScrollGroupSection>

</ScrollGroup>

---

### Autonomous Systems

In the real world, these little networks are called **autonomous systems** (AS for short). Each AS is owned and operated by some governing body, such as hosting providers (Google, Amazon, Cloudflare), ISPs (Telus, Bell), or universities. Together, there are around 90 thousand ASes and hundreds of millions of routers in the Internet.

Just like how Network 2 in our little internet is responsible for all addresses starting with "2", each AS is responsible for all addresses starting with a certain prefix.

Google's AS, for example, is responsible for all IP addresses starting with `142.251.33` — which means if a router sees that a data packet's destination IP address starts with `142.251.33`, it knows to send it to the router in Google's AS.

```
router prefix visual
```

---

Unlike the routers in our little internet, not every router in the Internet is connected to every other router. Instead, each AS has a group of routers called **border routers** that are connected to the routers of other ASes.

This would be like if our networks had a dedicated router to connect to the routers of other networks:

```
border router visual
```

This frees up our other router to focus on handling traffic within the AS.

---

Another difference with our little internet model is that **not every AS is connected to every other AS**. It's possible, and often very likely, that a data packet has to travel through multiple ASes to get to its destination.

```
visual with multiple AS hops
```

This lack of a direct connection means border routers don't necessarily store the destination router for every prefix. For the prefixes it can't directly reach, border routers store the **next hop**—the router that brings the data packet _closer_ to its destination.

---

## Border Gateway Protocol

This routing system works under the big assumption that every border router inherently knows how to reach every IP on the Internet. But, _how_ do they?

<ProblemStatement>

**How do border routers know how to get to every other border router in the Internet?** Is it a manually controlled list, or is there a more automated way?

</ProblemStatement>

---

<ScrollGroup>

<ScrollGroupSection>

Here's an idea: when an AS connects to other ASes, it will **announce** the prefixes it's responsible for to the connecting ASes. Those ASes in turn will announce the prefixes they're responsible for to their connecting ASes, and so on.

For example, let's say Network 3 wants to announce that it's responsible for all addresses starting with `3.1`. It'll start by announcing to Network 2 that all `3.1` addresses should be sent to Network 3.

</ScrollGroupSection>

<ScrollGroupSection>

When Network 2 receives this announcement, it'll update its routing table to say that all `3.1` addresses should be sent to Network 3. Network 2 will then announce to Network 1 that all `3.1` addresses should be sent to Network 2 (so it can then send it to Network 3).

</ScrollGroupSection>

<ScrollGroupSection>

When Network 1 receives this announcement, it'll update its routing table to say that all `3.1` addresses should be sent to Network 2.

All the networks in the system now know how to send data to Network 3!

</ScrollGroupSection>

<ScrollGroupSection>

Now let's add a direct connection between Network 1 and Network 3.

This time, when Network 3 announces the new prefix, Network 1 will update its routing table to say that all `3.1` addresses should be sent directly to Network 3:

</ScrollGroupSection>

<ScrollGroupSection>

But because Network 1 is also connected to Network 2, it will later receive an announcement from Network 2 that all `3.1` addresses should be sent to _Network 2_ instead. **What should Network 1 do in this case?**

```
bgp visual with direct connection
```

Since we can see the full picture, we know that Network 1 should disregard the Network 2 announcement because there's a direct connection to the destination. But Network 1 doesn't know this—to it, it's just receiving two announcements for the same prefix at two different points in time.

</ScrollGroupSection>

<ScrollGroupSection>

Network 1 doesn't have enough information to tie-break the two announcements. To help Network 1 decide, we need to add **the ASes the announcement has gone through** to the announcement.

With this, Network 1 can drop the Network 2 announcement because it knows that the direct connection to Network 3 is faster.

</ScrollGroupSection>

</ScrollGroup>

---

This algorithm we just saw is called the **Border Gateway Protocol** (BGP for short). It's _the_ algorithm responsible for keeping the Internet together.

---

<Aside label="Facebook's BGP Outage">

In October 2021, a bunch of Facebook's services, including Instagram, WhatsApp, and Facebook itself, were unavailable for about 5.5 hours.

The outage happened because Facebook's DNS servers (that knows how to translate `facebook.com` and other Facebook-owned domains to IP addresses) were removed from routing tables—making them impossible to reach.

Just like how ASes can _announce_ that they can reach a certain prefix, they can also _withdraw_ a certain path to a prefix.

```
bgp visual with withdrawal
```

In this case, Facebook's ASes made several withdrawals, saying to the other ASes that their DNS servers are no longer reachable—completely disconnecting them from the rest of the Internet.

Cloudflare and Facebook wrote extensive blog posts on this outage if you're interested in learning more:

- [https://blog.cloudflare.com/october-2021-facebook-outage/](https://blog.cloudflare.com/october-2021-facebook-outage/)
- [https://engineering.fb.com/2021/10/05/networking-traffic/outage-details/](https://engineering.fb.com/2021/10/05/networking-traffic/outage-details/)

</Aside>

---

## How Data Flows Through the Internet

With that, we have a complete picture of what happens when we visit a website or make a `fetch` call to an API:

1. First, your computer converts the domain name into an IP address using its saved DNS resolver.
2. Then, it sends data to your connected router, attaching the destination IP address to the data packet.
3. The router checks the destination IP address against its routing table and sends the data packet to the next hop.
4. This process repeats until the data packet reaches its destination.

Of course, this is a very simplified view of how the entire process works. I've skipped over a lot of details here, such as how the packet makes it to your ISP's border router or how the data packet is encrypted so it can't be read by anyone else—but that's for another post.

For now, thanks for reading!