import Visualizer from '../components/Visualizer'
import Details from '../components/Details'
import Layout from '../components/Layout'
import Item from '../components/shared/Item'
import * as Figures from '../components/sliding-window'
import snapshot from '../lib/snapshot.macro'

export const meta = {
  title: 'The Sliding Window Pattern',
  blurb: 'A method to optimize subarray problems.',
  publishDate: '2021-02-04',
  slug: 'sliding-window',
}

export default ({ children }) => <Layout meta={meta}>{children}</Layout>

## A Subarray Problem

The sliding window pattern is a neat and simple pattern to optimize problems involving _subarrays_. Let's go over a simple problem to see how this can be useful.

For this problem, we are given an array `arr`, and a subarray size `k`, and we are asked to find the _average_ of _all_ subarrays in `arr` of size `k`. So given an array like `[1, 2, 3, 4]` and a subarray size `k = 2`, the correct answer would be `[1.5, 2.5, 3.5]` because:

- `[1, 2, 3, 4]` has three subarrays of size 2, namely `[1, 2], [2, 3], [3, 4]`.
- The average of the first subarray is `1 + 2 / 2 = 1.5`, the average of the second is `2.5` (using the same formula), and the average of the third is `3.5`.
- Putting this together we get the final result `[1.5, 2.5, 3.5]`.

Given these steps, it seems pretty clear that in designing an algorithm to solve this problem we would have to (1) iterate through every subarray then (2) find the average of each and append it to the result array.

A straightforward way to find every subarray of an array is to iterate through each index of the array and _construct_ the subarray that begins at that index by iterating `k` more times. In this second iteration we can also sum up the numbers to compute the resulting average. Here's what that would look like:

<Visualizer
  initialInputs={[[1, 2, 3, 4]]}
  algorithm={snapshot((arr) => {
    let sum = 0
    const window = []
    for (let i = 1; i < 4; i++) {
      sum += arr[i]
      window.push(i)
      debugger
    }
    return sum
  })}
>
  {({ state }) => (
    <React.Fragment>
      <div className="flex w-full justify-center">
        {state.arr.map((item, index) => (
          <Item key={index} active={state.window.includes(index)}>
            {item}
          </Item>
        ))}
      </div>
      <p className="font-mono w-full text-center mt-4">
        k = 2 sum: {state.sum}
      </p>
    </React.Fragment>
  )}
</Visualizer>

Doing that for _every_ index in the array, we get the final algorithm:

<Visualizer
  initialInputs={[[1, 2, 3, 4, 5, 6], 3]}
  algorithm={snapshot((arr, k) => {
    const result = []
    for (let i = 0; i <= arr.length - k; i++) {
      let sum = 0
      for (let j = 0; j < k; j++) {
        sum += arr[i + j]
        debugger
      }
      result.push(sum / k)
    }
    debugger
    return result
  })}
  caption="This is an interactive demo! Press the pencil icon to change the values of arr and k."
  editable
>
  {(context) => <Figures.Quadratic {...context} />}
</Visualizer>

Notice the number on the top right of the animation. This number represents the total number of steps required to compute the result given the inputs `arr` and `k`. Try adding two more items and see how that number changes‚Äîit went up, by a _lot_.

Is there a better way?

Looking back at the algorithm, notice that most of the time we're counting numbers that we've already included before. Let's look at the animation again, this time highlighting all the double counts in red:

<Visualizer
  initialInputs={[[1, 2, 3, 4, 5, 6], 3]}
  algorithm={snapshot((arr, k) => {
    const result = []
    const counted = []
    const doubleCounted = []
    for (let i = 0; i <= arr.length - k; i++) {
      const subarray = [i]
      let sum = 0
      for (let j = 0; j < k; j++) {
        subarray.push(i + j)
        sum += arr[i + j]
        if (counted.includes(i + j)) {
          doubleCounted.push(i + j)
        }
        debugger
      }
      subarray.forEach((item) => counted.push(item))
      result.push(sum / k)
    }
    debugger
    return result
  })}
  editable
>
  {(context) => <Figures.DoubleCount {...context} />}
</Visualizer>

When the algorithm finishes, only 2 elements **were not double counted!** It turns out that no matter what inputs, this implementation will _always_ double count every element except for the first and the last (try playing around with the inputs to convince yourself).

So why are we double counting in the first place? If we look at the first two subarrays, we see there's a lot of overlap:

<Visualizer>
  <Figures.Comparison />
</Visualizer>

What if, on each step, we only take into account the _differences_ instead? In other words, is there a way to get the sum of the second subarray from the sum of the first? If so, we would be able to _derive_ the sum of the second subarray rather than recounting every element again.

In the example above, we can get the sum of the **second subarray by subtracting 1 and adding 5** to the sum of the first.

<Visualizer
  initialInputs={[[1, 2, 3, 4]]}
  algorithm={snapshot((arr) => {
    let window = [0, 3]
    let sum = 0
    arr.slice(...window).forEach((item) => (sum += item))
    debugger
    let diff = -arr[0]
    window = [1, 3]
    sum -= arr[0]
    debugger
    diff = arr[3]
    window = [1, 4]
    sum += arr[3]
    debugger
  })}
  delay={700}
>
  {({ state }) => <Figures.Derive state={state} />}
</Visualizer>

This reduces the sum computation from `k` iterations to only one iteration! This is also where the sliding window namesake comes from‚Äîit's as if we have a window of 4 items that we _slide_ to the next subarray.

Maybe adding a border around the items would make the window more clear:

<Visualizer
  initialInputs={[[1, 2, 3, 4]]}
  algorithm={snapshot((arr) => {
    let sum = 0
    let window = [0, 3]
    arr.slice(...window).forEach((item) => (sum += item))
    debugger
    sum = 0
    window = [1, 4]
    arr.slice(...window).forEach((item) => (sum += item))
    debugger
  })}
  delay={700}
  controls
>
  {({ state }) => <Figures.Window state={state} />}
</Visualizer>

With this key insight let's rewrite the algorithm. Remember that the algorithm receives two inputs - an array of numbers `arr` and a size of subarray `k`.

1. At the start, we _build_ the window‚Äîiterate until our window contains `k` items‚Äîwhile keeping track of the sum.
2. Then, we _slide_ the window one item over, updating the sum by subtracting the item no longer in the window and adding the item that was added to the window. By doing this we ensure that the sum stays in sync with the items that are in the window.
3. With this sum we can compute the average as before.

<Visualizer
  initialInputs={[[1, 2, 3, 4, 5, 6], 3]}
  algorithm={snapshot((arr, k) => {
    const result = []
    let windowStart = 0
    let windowSum = 0
    for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {
      windowSum += arr[windowEnd]
      debugger
      if (windowEnd >= k - 1) {
        result.push((windowSum / k).toFixed(2))
        windowSum -= arr[windowStart]
        windowStart++
      }
    }
    debugger
    return result
  })}
  delay={600}
  controls
  editable
>
  {({ state }) => <Figures.Optimal state={state} />}
</Visualizer>

And that's the find all averages problem using the sliding window pattern! Notice how this implementation only needs 7 steps to calculate the sum instead of 13 with the previous implementation. Now that doesn't seem to be too big of a difference, but look how blazing fast the optimal implementation is compared to our previous one:

<Visualizer
  initialInputs={[[1, 3, 2, 6, -1, 4, 1, 8, 2], 3]}
  caption="The animation speed is set to 400ms for both implementations!"
  editable
  algorithm={[
    snapshot((arr, k) => {
      const result = []
      let windowStart = 0
      let windowSum = 0
      for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {
        windowSum += arr[windowEnd]
        debugger
        if (windowEnd >= k - 1) {
          result.push(windowSum / k)
          windowSum -= arr[windowStart]
          windowStart++
        }
      }
      debugger
      return result
    }),
    snapshot((arr, k) => {
      const result = []
      for (let i = 0; i <= arr.length - k; i++) {
        let sum = 0
        for (let j = 0; j < k; j++) {
          sum += arr[i + j]
          debugger
        }
        result.push(sum / k)
      }
      debugger
      return result
    }),
  ]}
>
  {({ state: [optimal, quadratic], inputs }) => (
    <React.Fragment>
      <h4 className="text-gray-500 font-semibold text-center">Optimal üèé</h4>
      <Figures.OptimalMin state={optimal} />
      <h4 className="text-gray-500 font-semibold text-center my-8">Naive üêå</h4>
      <Figures.Quadratic state={quadratic} />
    </React.Fragment>
  )}
</Visualizer>

While the window is building, both algorithms are going at the same pace (try changing the size of k to equal to the size of the array‚Äîboth algorithms will finish at the same time!). However, once the window is complete, the optimal algorithm blazes off and terminates in less than half the time it takes for the naive algorithm to finish.

<Details label="‚è± A note on time complexity">

Admittedly comparing the runtime of two algorithms using an animated graphic isn't necessarily correct. Some algorithms naturally perform better on some inputs than others. The correct approach is to compare the algorithms' respective [time complexities](https://en.wikipedia.org/wiki/Time_complexity#:~:text=In%20computer%20science%2C%20the%20time,takes%20to%20run%20an%20algorithm.).

I wanted to avoid talking about time complexity for those not familiar with it, but I do think it's important to note what the time complexities actually _are_ for those who are curious.

**TL;DR**‚ÄîThe naive implementation is `O(nk)` while the optimal implementation is `O(n)`, where `n` is the size of the given array `arr`.

In the naive implementation, for every item in the array, we iterate `k` times to compute the subarray. This gives us a runtime of `O(nk)` where `n` is the size of the given array.

In the optimal implementation, we broke down the algorithm into two concrete steps‚Äîthe build step and the slide step. The time complexity of the algorithm is thus the sum of the build step and the slide step.

The build step is simply `O(k)` because we're only iterating until we reach the window size `k`. At a quick glance, the slide step is `O(n)` because we're iterating until the end of the array. However, we don't start at index `0`‚Äîwe start at index `k`. Therefore a more tight upper bound is `O(n - k)`. Adding the two together we get the final runtime of `O(n)`. A surprising find! Turns out the runtime of the optimal solution isn't reliant on the value of `k` at all.

</Details>

## Generalizing the Pattern

Of course we're not limited to only counting averages. The sliding window pattern can be generalized to any problem that involves computing _something_ in the subarray. As long as the problem has some definition of a window size, the pattern essentially boils down to:

1. Maintaining some **state** in that window, and
2. keeping that state in sync with the items in the window through **constant-time operations**.

By "constant-time operations" I mean without using further iterations and only using the stuff that leaves/enters the window.

In the case of the averages problem, the state that we're maintaining is the **sum of the items**. We're keeping this sum in sync with the items in the window by subtracting the item that's leaving and adding the item that's entering.

### Permutation in a String

Here's another problem that makes use of the same concept of maintaining state and synchronizing that state. The problem's pretty simple‚Äîgiven a string and some pattern, determine if the string contains any _permutation_ of that pattern. For example, given the string `aaacb` and the pattern `abc`, the algorithm should return `true` because the substring `acb` is a permutation of `abc`.

This is not as obvious of a sliding window problem than the problem we just worked through, but if you think of a string as an array of characters and a substring as a subarray, then the similarities start to show.

I'm not going to walk through each logical step to get to the optimal solution (that would take a minute!), but here are the main ideas:

1. A string can only be a permutation of another if it's the same length. _This gives us the size of the window = `pattern.length`_.
2. A string is **exactly** a permutation of another if it contains the exact same number of letters. A way to keep track of this is through a map of character -> count pairs. _This gives us the state that we have to maintain_.
3. We need a way to update _and compare_ the map in constant time. _Through this we fulfill the second condition of synchronizing state through constant operations_.

With those ideas, here's the final solution:

<Visualizer
  initialInputs={['aaacb', 'abc']}
  caption="Notice how similar it is to the averages problem?"
  algorithm={snapshot((str, pattern) => {
    const patternFrequencies = {}
    for (const char of pattern) {
      if (patternFrequencies.hasOwnProperty(char)) {
        patternFrequencies[char] = patternFrequencies[char] + 1
      } else {
        patternFrequencies[char] = 1
      }
    }
    let nonZeroCount = Object.keys(patternFrequencies).length
    let windowStart = 0
    for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {
      const char = str[windowEnd]
      if (patternFrequencies.hasOwnProperty(char)) {
        const val = patternFrequencies[char]
        patternFrequencies[char] = val - 1
        if (val === 1) {
          nonZeroCount--
        } else if (val === 0) {
          nonZeroCount++
        }
      }
      debugger
      if (nonZeroCount === 0) {
        return true
      }
      if (windowEnd >= pattern.length - 1) {
        const startChar = str[windowStart]
        if (patternFrequencies.hasOwnProperty(startChar)) {
          const val = patternFrequencies[startChar]
          patternFrequencies[startChar] = val + 1
          if (val === -1) {
            nonZeroCount--
          } else if (val === 0) {
            nonZeroCount++
          }
        }
        windowStart++
      }
    }
    return false
  })}
  delay={600}
  controls
  editable
>
  {({ state }) => <Figures.Permutation state={state} />}
</Visualizer>

If you're interested in more details of the algorithm (particularly the constant-time updates and comparison), open the note below!

<Details label="üóæ Constant time map comparisons">

One way to check if two strings have the exact same number of letters would be to:

1. Create a map of character -> count pairs for each string.
2. Loop through each character in each map, comparing the counts in each iteration.

Unfortunately this doesn't satisfy the "constant-time" condition because we have to loop through each character. It also doesn't take advantage of the fact that only _one_ letter is coming in and only _one_ letter is coming out of the window each time.

Looking at it from a different perspective, we can think of two maps as being equal if their _difference_ is zero. We consider a map to be "zero" if all of its keys have value zero. This gives us a goal‚Äîif we start with the map that corresponds to the pattern, and if we update it in some way such that it ends up being zero, we know we've reached a permutation.

At the start, this map is the state of the window. When we add a letter to the window, we _subtract_ that letter's count in the map. Conversely when we remove a letter from the window, we _add back_ that letter's count in the map. Since this sequence of updates can be performed in one iteration, we've satisfied the condition!

</Details>

## Summary

In conclusion, the sliding window pattern is a neat way to improve the runtime of problems involving subarrays. A lot of problems can be solved using this pattern, but the tricky part is finding how the pattern can fit into the problem. Once you're there, you're golden.
