import Visualizer from "../components/Visualizer";

import * as Figures from "../components/sliding-window";

# The Sliding Window Pattern

The sliding window pattern is a neat and simple pattern to optimize problems involving _subarrays_. Let's go over a simple problem to see how this can be useful.

For this problem, we are given an array `arr`, and a subarray size `k`, and we are asked to find the _average_ of _all_ subarrays in `arr` of size `k`. So given an array like `[1, 2, 3, 4]` and a subarray size `k = 2`, the correct answer would be `[1.5, 2.5, 3.5]` because:

- `[1, 2, 3, 4]` has three subarrays of size 2, namely `[1, 2], [2, 3], [3, 4]`.
- The average of the first subarray is `1 + 2 / 2 = 1.5`, the average of the second is `2.5` (using the same formula), and the average of the third is `3.5`.
- Putting this together we get the final result `[1.5, 2.5, 3.5]`.

Given these steps, it seems pretty clear that in designing an algorithm to solve this problem we would have to (1) iterate through every subarray then (2) find the average of each and append it to the result array.

A straightforward way to find every subarray of an array is to iterate through each index of the array and _construct_ the subarray that begins at that index by iterating `k` more times. In this second iteration we can also sum up the numbers to compute the resulting average. Here's what that would look like:

<Visualizer Component={Figures.Subarray} initialInputs={[[1, 2, 3, 4], 2]}>

```js
export default (arr) => {
  let sum = 0;
  const window = [];
  for (let i = 1; i < 4; i++) {
    sum += arr[i];
    window.push(i);
    debugger;
  }
  return sum;
};
```

</Visualizer>

Doing that for _every_ index in the array, we get the final algorithm:

<Visualizer
  Component={Figures.Quadratic}
  initialInputs={[[1, 2, 3, 4, 5, 6], 4]}
  caption="This is an interactive demo! Press the pencil icon to change the values of arr and k."
  editable
>

```js
export default (arr, k) => {
  const result = [];
  for (let i = 0; i <= arr.length - k; i++) {
    let sum = 0;
    for (let j = 0; j < k; j++) {
      sum += arr[i + j];
      debugger;
    }
    result.push(sum / k);
  }
  debugger;
  return result;
};
```

</Visualizer>

Notice the number on the top right of the animation. This number represents the total number of steps required to compute the result given the inputs `arr` and `k`. Try adding two more items and see how that number changesâ€”it went up, by a _lot_.

Is there a better way?

Looking back at the algorithm, notice that most of the time we're counting numbers that we've already included before. Let's look at the animation again, this time highlighting all the double counts in red:

<Visualizer
  Component={Figures.DoubleCount}
  initialInputs={[[1, 2, 3, 4, 5, 6], 4]}
  editable
>

```js
export default (arr, k) => {
  const result = [];
  const counted = [];
  const doubleCounted = [];
  for (let i = 0; i <= arr.length - k; i++) {
    const subarray = [i];
    let sum = 0;
    for (let j = 0; j < k; j++) {
      subarray.push(i + j);
      sum += arr[i + j];

      if (counted.includes(i + j)) {
        doubleCounted.push(i + j);
      }

      debugger;
    }
    subarray.forEach((item) => counted.push(item));
    result.push(sum / k);
  }
  debugger;
  return result;
};
```

</Visualizer>

When the algorithm finishes, only 2 elements **were not double counted!** (try playing around with the inputs to convince yourself). It turns out that no matter what inputs, this implementation will _always_ double count every element except for the first and the last.

So why are we double counting in the first place? If we look at the first two subarrays, we see there's a lot of overlap:

<Visualizer
  Component={Figures.Comparison}
  initialInputs={[[1, 2, 3, 4, 5, 6], 4]}
  readOnly
>

```js
export default (arr, k) => {
  const result = [];
  const counted = [];
  const doubleCounted = [];
  for (let i = 0; i <= arr.length - k; i++) {
    const subarray = [i];
    let sum = 0;
    for (let j = 0; j < k; j++) {
      subarray.push(i + j);
      sum += arr[i + j];

      if (counted.includes(i + j)) {
        doubleCounted.push(i + j);
      }

      debugger;
    }
    subarray.forEach((item) => counted.push(item));
    result.push(sum / k);
  }
  debugger;
  return result;
};
```

</Visualizer>

What if, on each step, we only take into account the _differences_ instead? In other words, how do we get to the sum of the second subarray from the sum of the first? In the example above, we can get the sum of the **second subarray by subtracting 1 and adding 5** to the sum of the first. This is the key insight in getting to the optimal solution for this problem.
