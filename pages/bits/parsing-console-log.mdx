---
title: Parsing Console Log
---

One of the things that got me pretty stumped when implementing this was in parsing this seemingly simple expression:

```js
console.log(message)
```

In a syntax tree, this expression is known as a `CallExpression`. A `CallExpression` has two child nodes — a `callee`, which is itself an expression, and an array of arguments, which for the moment I've limited to `Identifier` nodes.

More formally, a `CallExpression` looks something like this:

```
CallExpression -> Expression "(" Identifier* ")"
```

Where it's an expression, followed by a left parenthesis, followed by 0 or more identifiers, ending with a right parenthesis.

So all of the following are valid call expressions:

```js
hello()
hello()()()
console.log()
console.log(one, two, three, messages)(1 + 2 + 3)()(await myPromise())()
```

(The second to last one there is a valid call expression _syntax_-wise, but it'll crash when you try running the program because `1 + 2 + 3` isn't a function).

The problem that I faced was this: how would the parser know that the `console` token is part of a call expression before it sees the left parenthesis?

When a parser iterates through the tokens, it’s only able to see what the current token is. All the other tokens that come after it is like shrouded in a fog:

```
[console] ############
```

Of course we can always add another cursor. When we do that, we’re peering into the fog to see what tokens come up next.

This process is called _lookahead_. My first attempt at parsing this call expression involved a lookahead. My logic was that if the token after the current one is a left parenthesis, then we should wrap the whole thing in a call expression.

Sounds like it would work, except it wouldn’t catch that `console.log()` is a call expression, because the left parenthesis isn’t just one token ahead, but _three_:

```
[console] [.] [log] [(] [message] [)]
  |					 |
cursor			   left paren token
```

Generally speaking, there may be an arbitrary number of tokens before you get to the parentheses:

```js
console.some.deeply.nested.func.call()
```

This brings us back to the original question - how do we know that we're parsing a `CallExpression` before we see the left parenthesis?

After trying to hack away at it for about an hour or so I turned to the Crafting Interprets book to find some answers. There, I found exactly what I was looking for. The key insight is to parse as an _identifier first_, then "fix" the result once we realize that it's a `CallExpression`. I felt quite dumb when I saw this because, in hindsight, this was a pretty obvious way of going about it.

Let's walk through the `console.log` example. Here's our list of tokens:

```
[console]   [.]  [log]       [(]        [message]   [)]
 Identifier  Dot  Identifier  LeftParen  Identifier  RightParen
```

Let's add the fog back in to more accurately show what the computer sees:

```
[console] #######
 ^
```

We see `console`, which is an `Identifier` token, so we parse it as an identifier.

```
[console] #######
 ^

 {
 	type: "Identifier",
	name: 'console'
 }
```

We advance the cursor and we see... a dot!

Cool, this tells us that our `Identifier` node actually should be a `MemberExpression`. So let's create a `MemberExpression` node and put our `Identifier` node as its object:

```
[console] [.] #######
 		   ^

{
	type: "MemberExpression",
	object:  {
		type: "Identifier",
		name: 'console'
    },
	property: ???
}
```

We still need to fill in `property` which, if the syntax is correct, should be the next token that we see:

```
[console] [.] [log] #######
 		       ^

{
	type: "MemberExpression",
	object:  {
		type: "Identifier",
		name: "console"
    },
	property: {
		type: "Identifier",
		name: "log"
	}
}
```

And it's all good! We find the next token is indeed an `Identifier` token, and we parse that as the member expression's `property` field.

What's next?

```
[console] [.] [log] [(] #######
 		             ^

{
	type: "MemberExpression",
	object:  {
		type: "Identifier",
		name: "console"
    },
	property: {
		type: "Identifier",
		name: "log"
	}
}
```

We find a `LeftParen`! Ok, this means that our `MemberExpression` actually should be a `CallExpression`. Let's fix that:

```
[console] [.] [log] [(] #######
 		             ^

{
	type: "CallExpression",
	callee: {
		type: "MemberExpression",
		object:  {
			type: "Identifier",
			name: "console"
		},
		property: {
			type: "Identifier",
			name: "log"
		}
	},
	arguments: ???
}
```

We still need to parse the list of arguments, so we'll treat the next few tokens as the arguments.

```
[console] [.] [log] [(] [message] #######
 		                 ^

{
	type: "CallExpression",
	callee: {
		type: "MemberExpression",
		object:  {
			type: "Identifier",
			name: "console"
		},
		property: {
			type: "Identifier",
			name: "log"
		}
	},
	arguments: ???
}
```

We find an `Identifier` token, so let's add an `Identifier` node to our argument list:

```
[console] [.] [log] [(] [message] #######
 		                 ^

{
	type: "CallExpression",
	callee: {
		type: "MemberExpression",
		object:  {
			type: "Identifier",
			name: "console"
		},
		property: {
			type: "Identifier",
			name: "log"
		}
	},
	arguments: [
		{
			type: "Identifier",
			name: "message"
		}
	]
}
```

Let's continue.

```
[console] [.] [log] [(] [message] [)]
 		                           ^

{
	type: "CallExpression",
	callee: {
		type: "MemberExpression",
		object:  {
			type: "Identifier",
			name: "console"
		},
		property: {
			type: "Identifier",
			name: "log"
		}
	},
	arguments: [
		{
			type: "Identifier",
			name: "message"
		}
	]
}
```

Ah, a `RightParen`! That means our argument list is complete. Since there are no more tokens remaining, our `CallExpression` is complete as well. This means we're done parsing!

And there we have it - a little trick to parse our favourite little function call: `console.log`.
