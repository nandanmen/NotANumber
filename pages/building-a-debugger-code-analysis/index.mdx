---
title: 'Building a Debugger: Code Analysis'
blurb: 'Exploring the power of the Babel plugin ecosystem.'
publishDate: '2021-04-15'
---

import Callout from '../../components/Callout'
import Widget from '../../components/Widget'
import SelectQuestion from '../../components/quiz/SelectQuestion'
import Architecture from '../../components/building-a-debugger-code-analysis/Architecture'
import EmbeddedSandbox from '../../components/building-a-debugger-code-analysis/EmbeddedSandbox'
import EmbeddedTranspiler from '../../components/building-a-debugger-code-analysis/EmbeddedTranspiler'
import VisitorSandbox from '../../components/building-a-debugger-code-analysis/VisitorSandbox'
import 'twin.macro'

A couple of months ago, I shipped [Playground]() — a web-based JavaScript debugger that lets you write JS code and attach breakpoints using the `debugger` statement. It was the first personal project that I saw through to completion, and it was an incredible opportunity for me to dip my toes in web technologies I've never used before.

I learned a _ton_, and in the next little bit I want to talk about what exactly I found out. I'll first go over the overall architecture of the app, then I'll dive deep into the specifics behind the two components that make up the core app logic.

In this post, I'll go over the first core piece: the transpiler. Let's get started!

## Architecture

Before we dive too deeply, let's look at the architecture of the app from a bird's eye view:

The app is split into four different parts, orchestrated as a "pipeline" that takes in user code and outputs debug data. Each component of the pipeline has its own responsibilities:

1. **Editor** — Allow users to input code
2. **Transpiler** — Takes the user's code and transforms it
3. **Evaluator** — Takes the transformed code and runs it, returning the debug state
4. **Debug Panel** — Takes the debug state and displays it to the user

For the rest of this article, we're going to be focusing our attention to that "Transpiler" component. What exactly does it do? How does it work? Read on to find out.

## Taking a Peek

The main responsibility of the transpiler is to modify the code so that the rest of the app can know what's going on inside the function as it's running. For debuggers, knowing "what's going on" inside a function typically means knowing the values of local variables at any given time. Now the question becomes: how do we get those values out of a function?

If you're doing it manually, you can update the implementation of your function to save the data to some external variable:

```js
const variables = []

function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}

sum([1, 2, 3])
// here, variables is an array of {num, arr, sum}
```

This is great, but it's tedious — every time you want to record the local variables, you have to add that `variables.push` code as well as list down all of the variables you want to record. It would be nice if we can generate this code automatically; the only thing we need to do is tell the computer when we want the variables to be recorded. In fact, this is precisely what the transpiler does.

The transpiler makes use of the lesser known `debugger` keyword in JavaScript to indicate when local variables should be recorded. Once it sees a `debugger` keyword, it turns it into something like the `variables.push` code that we just wrote.

<EmbeddedTranspiler>

Try to add some more `debugger` statements in the code to see how the transpiler converts it.

</EmbeddedTranspiler>

<Callout label="The transpiler powers this blog!">

The animations in my [sliding window post](../sliding-window) is powered, in part, by a module very similar to the transpiler. Each animation begins with a function, just like the sum function we wrote above. At build time, the module transforms all of these functions in the exact same way the transpiler transforms your code. When the transformed code is called, the resulting states becomes the animation steps that you see on the page!

</Callout>

## Automatic Transformation

So how exactly would we write something to transform the code automatically? At the end of the day, the code you write is just a very long string, so let's start with that. Using this string, you could _technically_ use regex to replace all instances of `debugger` with something else:

```jsx
code.replace(/debugger/, 'variables.push({ ... })')
```

This kinda works, but then you have more problems — how do you know which variables are in scope? Which of those variables are declared _and_ in scope? So you start over, use more regex to find `const`, `let`, `var`, ....

Ok — working with strings kinda suck. Instead, let's try to convert the code string into a structure that's a lot easier to work with. How about trees?

### Abstract Syntax Trees

The recursive structure of code fits quite nicely with the recursive structure of trees. Take the snippet that we used earlier:

```jsx
const variables = []

function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}

sum([1, 2, 3])
```

You can say the whole snippet is a "Program" that has three "children" — the variable declaration at the top, the function definition in the middle, and the function call at the end. Going a level deeper, you have:

- The variable name and the array literal in the variable declaration;
- The various lines of code in the function definition;
- The function name and list of parameters in the function call;

If we try to draw this hierarchy out and put labels on each code structure, you might get something like:

<EmbeddedSandbox
  initialCode={`const variables = []
function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}
sum([1, 2, 3])`}
  depth={1}
  hideEditor
  hideDetailView
>

This goes deeper! Try pressing the + icons to see what's next.

</EmbeddedSandbox>

This tree-like representation of code is commonly known as an abstract syntax tree or AST for short. In an AST, code is represented as nodes where each node has a type property describing the kind of code that it corresponds to. By representing the code in this way, you have access to a lot more information about the code and its semantic meaning — making it much easier to manipulate it in the way that you want.

### Wait, don't we still have to deal with strings?

You might be thinking, "Hey Nanda, you still have to turn the code into the tree somehow. Don't you have to use regex nevertheless?" You're exactly right! That entire process, also known as lexing and parsing, warrants an entire article on its own; we won't talk about it much here. For the rest of this article, we'll talk about and make use of Babel's parsing APIs, which generously takes care of the difficult parsing for us. All we have to do is think about what to do with the tree once we have it.

## Babel's APIs

Let's diverge a bit here and talk about Babel's API.

Fundamentally, Babel is a JavaScript compiler. It takes in JS code, applies transformations to the code, and outputs JS code. It does this by parsing the code into an AST (just like the one we saw in the previous section!), manipulating the AST, and finally converting the AST back into code.

Babel's ASTs are quite expressive; take a look at the representation for a function call when you show all available properties:

<EmbeddedSandbox initialCode={`helloWorld()`} hideEditor showProps />

Out of the box, Babel doesn't apply any transformations to your code — you would need to provide it a series of plugins for it to do anything. A Babel plugin is a regular function that returns an object with a visitor property:

```js
export default function (babel) {
  return {
    visitor: {
      /* ... */
    },
  }
}
```

The function receives the babel object as an argument, which includes a very handy `types` property that we'll take advantage of later on. We'll talk about visitors in more detail next.

## Be My Guest

Just like how you can convert code into ASTs, you can convert ASTs _back_ into code. This means that transforming code is a matter of transforming one AST to another. "Transforming" in this case means to visit each node of the tree and do something with it, e.g. changing the node to another node, adding child nodes, removing child nodes, removing the node itself, etc. There's various ways to traverse a tree, but Babel makes it easy by using something called a **visitor**.

A visitor is a lookup table of functions where each function corresponds to a particular node type:

```js
const visitor = {
  Identifier(node) {
    // do stuff with the Identifier node
  },
  VariableDeclaration(node) {
    // do stuff with the VariableDeclaration node
  },
  /* do more stuff with more nodes */
}
```

As Babel visits each node in the tree, it looks at the visitor object to see if that node has a corresponding function. If it does, Babel calls the function, potentially modifying the node in the process.

### Paths

Often, the node alone isn't enough information to do what you want. If you want to modify just one part of the code for example, you would also need to know _where_ the node is relative to everything else. For this reason, Babel provides a `path` object instead that has a bunch of properties describing the _context_ of the node we're currently visiting. This means it's more accurate to show the visitor as:

```js
const visitor = {
  Identifier(path) {
    const node = path.node
    // do stuff with the Identifier node
  },
  VariableDeclaration(path) {
    // do stuff with the VariableDeclaration node
  },
  /* do more stuff with more nodes */
}
```

I highly recommend [Jamie Kyle's Babel Plugin Handbook](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-visitors) for more on visitors, paths, and AST traversals.

## Refactoring Legacy Code

Let's put our newfound knowledge of visitors and the Babel APIs to work by going through some scenarios.

### No `var`s, Please

Nowadays, it's generally best practice to use only `const` or `let` to declare variables in JavaScript. However, any code written before ES2015 was around would've used `var` to declare its variables. You've been a JS developer for a while, and one day you decide to modernize one of your old codebases. The first step is to change all `var` variables to `let` variables.

You recently read up on ASTs and Babel plugins, so you know you could write a custom babel plugin to do this. You also know that you should write a "visitor" of some kind. The question is, what does that visitor look like?

To start off, let's play around with the code to see what AST our intended code maps to:

<EmbeddedSandbox
  initialCode={`var a = 10`}
  whitelist={new Set(['kind'])}
  depth={2}
/>

It looks like the node type we're looking for is the `VariableDeclaration` node, since it's the node that corresponds to the `var a = 10` code. It also has a `kind` property that tells you what type of variable it is. How convenient!

Let's see what the AST looks like when we use `let` instead:

<EmbeddedSandbox
  initialCode={`let a = 10`}
  whitelist={new Set(['kind'])}
  depth={2}
/>

Looks like the difference is only in the `kind` property! Cool, that means all we need the visitor to do is (1) target the `VariableDeclaration` node type and (2) change the `kind` property from `"var"` to `"let"`:

<VisitorSandbox
  initialCode={`var a = 10
const b = 20
var c = 60`}
  visitor={`export default () => ({
  visitor: {
    VariableDeclaration(path) {
      if (path.node.kind === 'var') {
        path.node.kind = 'let'
      }
    },
  }
})`}
/>

And sure enough, that works great.

### `import`s too, please!

As of version 13.2, Node supports ECMAScript modules. This means you're able to use `import` and `export` instead of `require` and `module.exports` as long as you set the appropriate type field in `package.json`.

Let's see if we can make a Babel plugin that converts imports using `require` to imports using `import`. As a quick primer, importing using `require` looks like:

```js
const myModule = require('./my-module')
```

Whereas importing using `import` looks like:

```js
import * as myModule from './myModule'
```

To keep it simple, we're only going to convert **top-level** imports. This means we're going to ignore any `require` calls that happen dynamically, such as in a function body.

```js
const myModule = require('./my-module') // convert this

function helloWorld() {
  const printer = require('./printer') // don't convert this
  printer.print('hello world!')
}
```

Let's start by taking a look at the AST for the `import` way of importing modules:

<EmbeddedSandbox
  initialCode={`import * as myModule from './my-module'`}
  depth={Number.POSITIVE_INFINITY}
/>

Now let's compare that to the `require` way:

<EmbeddedSandbox
  initialCode={`const myModule = require('./my-module')`}
  depth={Number.POSITIVE_INFINITY}
/>

Immediately it's clear that, based on the AST alone, there's no similarity between the two ways of importing modules. Using `require`, importing a module is no different than calling a function. Unlike the `var` example from before, we can't simply point to a "Require" node type — we have to check for ourselves if the function call is a call to `require`. We also have to keep note of the name that we're assigning to the imported module.

With that in mind, which **node type** should we target in our visitor to get this information? Keep in mind that:

- We're starting from the `require` AST, and
- Each node has access to all of its children (e.g. a `Program` node has access to all of the nodes in its body)

<SelectQuestion>
  <SelectQuestion.Option value="CallExpression"></SelectQuestion.Option>
  <SelectQuestion.Option value="Program"></SelectQuestion.Option>
  <SelectQuestion.Option value="VariableDeclaration"></SelectQuestion.Option>
</SelectQuestion>

## Building the Visitor

Now that we have access to these new tools, let's try to piece together the visitor for our debugger. To recap, we want to change every instance of `debugger` with code that adds all variables in scope to some global array (in this case, an array called `_variables`). Something like:

```js
_variables.push({
  /* all variables in scope */
})
```

### Try it for Yourself!

Before I go over the solution, try to build it for yourself! A couple things to keep in mind about the API:

- **Plugin API** — A Babel plugin is a function that returns an object with a `visitor` property. This boilerplate is done for you in the sandbox below; all you need to do is fill in the visitor object.
- **@babel/types** — The visitor has access to a variable called `utils` which is a collection of helper functions from the [@babel/types]() library. Each node type has an associated "builder" function with the same name, e.g. you can build an `Identifier` node using the `utils.identifier()` function. I **strongly recommend** using these when creating new nodes.
- **Scope** — The `path` object passed to each visitor function contains a very useful `scope` property; use the `scope.getAllBindings()` function to get an array of all variables in scope.

> Placeholder: add visitor sandbox
