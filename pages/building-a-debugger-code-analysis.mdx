---
title: 'Building a Debugger: Code Analysis'
blurb: 'Exploring the power of the Babel plugin ecosystem.'
publishDate: '2021-03-15'
---

import Architecture from '../components/building-a-debugger-code-analysis/Architecture'

A couple of months ago, I shipped [Playground]() — a web-based JavaScript debugger that lets you write JS code and attach breakpoints using the `debugger` statement. It was the first personal project that I saw through to completion, and it was an incredible opportunity for me to dip my toes in web technologies I've never used before.

I learned a _ton_, and in the next little bit I want to talk about what exactly I found out. I'll first go over the overall architecture of the app, then I'll dive deep into the specifics behind the two components that make up the core app logic.

In this post, I'll go over the first core piece: the transpiler. Let's get started!

## Architecture

Before we dive too deeply, let's look at the architecture of the app from a bird's eye view:

<Architecture />

The app is split into four different parts, orchestrated as a "pipeline" that takes in user code and outputs debug data. Each component of the pipeline has its own responsibilities:

1. **Editor** — Allow users to input code
2. **Transpiler** — Takes the user's code and transforms it
3. **Evaluator** — Takes the transformed code and runs it, returning the debug state
4. **Debug Panel** — Takes the debug state and displays it to the user

For the rest of this article, we're going to be focusing our attention to that "Transpiler" component. What exactly does it do? How does it work? Read on to find out.

## Taking a Peek

The responsibility of the Transpiler is to modify the user's code in such a way that the app knows what's going on inside the function while it's running.
