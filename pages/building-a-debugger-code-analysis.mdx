---
title: 'Building a Debugger: Code Analysis'
blurb: 'A crash course in writing your own Babel plugin.'
publishDate: '2021-05-02'
---

import Aside from '../components/Aside'
import Callout from '../components/Callout'
import Widget from '../components/Widget'
import Video from '../components/shared/Video'
import EmbeddedSandbox from '../components/building-a-debugger-code-analysis/EmbeddedSandbox'
import EmbeddedTranspiler from '../components/building-a-debugger-code-analysis/EmbeddedTranspiler'
import VisitorSandbox from '../components/building-a-debugger-code-analysis/VisitorSandbox'
import BabelPipeline from '../components/building-a-debugger-code-analysis/BabelPipeline'
import TraverseVisitor from '../components/building-a-debugger-code-analysis/TraverseVisitor'
import 'twin.macro'

A couple of months ago, I shipped [Playground](https://playground.narendras.vercel.app/) — a web-based JavaScript debugger that lets you write JS code and attach breakpoints using the `debugger` statement. It was the first personal project that I saw through to completion, and it was an incredible opportunity for me to dip my toes in web technologies I've never used before.

I learned a _ton_, and in the next little bit, I want to talk about how exactly it works. In the process, we're going to build our own mini-debugger using Babel's plugin APIs. Let's get started!

## Architecture

<Widget className="full-width">
  <Video src="/playground.mp4" autoPlay playsInline loop />
</Widget>

The app consists of a React UI and a pipeline with two parts: the **code transpiler** and the **code runner**. When a user types in code in the editor on the left, the code is sent into the pipeline and gets processed by both the transpiler and the runner. After the code is processed, the result (a list of variable values) gets sent back to the React app to display.

Within the pipeline, the transpiler transforms the code into code that is "debuggable". Then, the runner evaluates that code and passes on the result back to the React app.

But how do you transform code? What does "debuggable" even mean? Let's find out by rebuilding it ourselves.

## Taking a Peek

The sole responsibility of the transpiler is to modify the code so that the rest of the app can know what's going on inside the function as it's running. For debuggers, knowing "what's going on" inside a function typically means knowing the values of local variables at any given time. Now the question becomes: how do we get those values out of a function?

If you're doing it manually, you can update the implementation of your function to save the data to some external variable:

```js highlight=6
const variables = []

function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}
```

Then, when you call the function, you can read that variable to know what's going on inside:

```js
sum([1, 2, 3])

console.log(variables) // { num: 1, arr: [1,2,3], sum: 0 }, ...
```

This works totally fine for small and one-of functions, but it doesn't scale too well. When you have large functions and lots of internal variables, you have to scan through each one and add them yourself. In terms of Playground, it also doesn't make sense to make the user do this themselves — there's too much friction!

This brings us to our problem:

<Aside title="The Problem">
  
How do we automatically record the values of variables inside a function?

</Aside>

## Problem 1: Where to put it?

Our first problem is a simple one – if we're generating these save calls automatically, _where_ in the function should we put them?

I messed around with ways to automatically inject these calls, but ultimately I felt it made more sense for the users to specify where they want to debug. Of course, this indicator to be easy to write, otherwise we're back to the original problem. In the end, I landed on using the [debugger](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) keyword as the indicator.

Before we jump into the _how_, here's a demo of the _what_. As a whole, the transpiler turns any `debugger` statement into a save call like `variables.push({ ... })`:

<EmbeddedTranspiler>

Try to add some more `debugger` statements in the left panel to see how the transpiler converts it.

</EmbeddedTranspiler>

## Problem 2: Automatic Transformation

So how exactly would we write something to transform the code automatically?

Since code is ultimately a very long string, we'll use strings as a starting point. Then, we can use a regex matcher to change every instance of `debugger` with our save call:

```jsx
code.replace(/debugger/, 'variables.push(/* stuff */)')
```

This is a promising start, but this approach really breaks down when you start needing information from the code. What are the variables in scope _right now_? What are the names of those variables? Are those variables declared? Can we safely use them?

Can you think of a way to answer these questions using solely regex operations? (I can't). Clearly, we need a better way to represent code — ideally, one that lets us easily answer questions like these.

### Abstract Syntax Trees

By far the most common way of representing code uses something called an **abstract syntax tree**, or AST for short. In an AST, source code is broken apart and grouped into "nodes" based on the structure that they represent.

...That probably sounds a bit cryptic, so let's look at an example. Here, I have the `sum` function from before:

```jsx
const variables = []

function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}

sum([1, 2, 3])
```

ASTs always start with the entire source code as one node called the Program node:

<EmbeddedSandbox
  initialCode={`const variables = []\n
function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}\n
sum([1, 2, 3])`}
  depth={0}
  hideEditor
  hideDetailView
/>

Next, we break down this source code into smaller nodes based on the code structure it represents. Here, our code consists of three parts — declaring the variable at the top, defining a function in the middle, and calling the function at the end. So let's add three more nodes to the Program node:

<EmbeddedSandbox
  initialCode={`const variables = []\n
function sum(arr) {
  let sum = 0
  for (const num of arr) {
    variables.push({ num, arr, sum })
    sum += num
  }
  return sum
}\n
sum([1, 2, 3])`}
  depth={1}
  hideEditor
  hideDetailView
/>

This process gets repeated until you can't break down the code any further. Try pressing the '+' button next to the node labels to see how that node gets broken down.

By representing the code in this way, we have access to a lot more information about the code and its semantic meaning — making it much easier to manipulate it in the way you want (like to write a debugger, perhaps?).

But our original problem still holds — don't we have to manipulate the code string to generate this tree in the first place?

## The Babel APIs

<Aside title="The Problem">
  
How do we take our original code string and turn it into an AST? I talked briefly about what ASTs are, but I never solved the actual problem — we still have to deal with strings anyway!

</Aside>

To solve this problem, we're going to take advantage of [the Babel library](https://babeljs.io/). In particular, we're going to let Babel do the code parsing for us so that we can focus on manipulating the AST.

Fundamentally, Babel is a JavaScript compiler — it's a program that takes in JS code and outputs JS code, potentially modifying it in the process. It does this by parsing the code into an AST, manipulating that AST through plugins, and finally converting the AST back into code.

<Widget className="full-width">
  <BabelPipeline />
</Widget>

In fact, the AST that we saw in the previous section was an AST generated by Babel; although admittedly, I've cut out a bunch of properties to make the concept more clear. In truth, Babel's ASTs are a lot more expressive. For example, here's the 'raw' AST for a function call with all the original properties shown:

<EmbeddedSandbox initialCode={`helloWorld()`} hideEditor showProps />

If you want to see what kind of AST Babel generates for other pieces of code, play around with the sandbox here:

<EmbeddedSandbox
  initialCode={`function hello() {
  console.log('hello world')
}`}
/>

### Plugins

Out of the box, Babel doesn't apply any transformations to your code — you would need to provide it a series of plugins for it to do anything. A Babel plugin is a function that modifies an AST using something called a visitor. It looks something like this:

```js
export default function (babelInstance) {
  return {
    visitor: {
      Identifier(node) {
        // do stuff with the Identifier node
      },
      VariableDeclaration(node) {
        // do stuff with the VariableDeclaration node
      },
      /* do more stuff with more nodes */
    },
  }
}
```

Most, if not all, of the logic of modifying the AST lies in this visitor object — we're going to focus the rest of this post on talking about what it is and how it works.

## Be My Guest

<Aside title="The Problem">
  
How do you modify an AST?

</Aside>

To transform an AST, you have to _traverse_ through the tree, modifying each node one at a time as you visit them. A visitor is used to describe _how_ different node types are modified as you visit each one. Here's how it works.

A visitor is an ordinary object with **node types** as keys and **handler functions** as values. The idea is simple — if the current node type matches one of the types we defined in the object, then call the handler function to modify the node.

For example, here's a visitor that has handlers for the `Identifier` node type and the `VariableDeclaration` node type:

```js
const visitor = {
  Identifier: function (node) {
    // do stuff with the Identifier node
  },
  VariableDeclaration: function (node) {
    // do stuff with the VariableDeclaration node
  },
  /* do more stuff with more nodes */
}
```

Whenever the traversal algorithm reaches a node, the algorithm checks in this visitor object for what to do. If there's a match, great — we call the handler function with the current node. Otherwise, we'll move on to the next node.

<Widget className="full-width">
  <TraverseVisitor />
</Widget>

This method of separating the traversal algorithm with the transformation process isn't unique to Babel — in fact, it's a classic design pattern called the aptly named [visitor design pattern](https://en.wikipedia.org/wiki/Visitor_pattern). By separating these concerns, plugin authors can focus solely on how they want to modify the tree — they never have to worry about how the tree traversal actually works.

### Paths

Admittedly, I lied a bit in the last section. A visitor in a Babel plugin doesn't take in the current node, but rather the current _path_. A path is a wrapper around an AST node with methods that let you figure out things like:

- The parent of the current node,
- The siblings (if any) of the current node,
- Which variables are in scope at the current node

As well as various methods to replace, remove, and insert nodes. For more on paths (and Babel's APIs in general), I highly recommend [Jamie Kyle's Babel Plugin Handbook](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-visitors).

## Building the Visitor

Now that we know a bit about visitors and ASTs, let's try to piece together our own Babel plugin to debug our code. To recap, we want to change every instance of `debugger` with code that records the values of all variables in scope:

<EmbeddedTranspiler />

### Try it for Yourself!

Before I go over the solution, try to build it for yourself! You should be able to build the plugin using everything we've discussed so far, but I'll give you one more hint:

- **Scope** — The `path` object passed to each visitor function contains a very useful `scope` property that contains methods dealing with all variables in scope. One method that could be useful is the `path.scope.getAllBindings()` method which returns an array of all variables currently in scope.

I've embedded a visitor and AST playground for you to use, and of course feel free to refer to the [babel types documentation](https://babeljs.io/docs/en/babel-types.html) if you need more information.

<VisitorSandbox
  initialCode={`function sum(arr) {
  let sum = 0
  for (const num of arr) {
    debugger
    sum += num
  }
  return sum
}`}
  visitor={`export default ({ types: t }) => ({
  visitor: {
    /* todo */
  },
})`}
/>

<EmbeddedSandbox
  initialCode={`function sum(arr) {
  let sum = 0
  for (const num of arr) {
    debugger
    sum += num
  }
  return sum
}`}
  depth={2}
/>

---

### Solution

Let's work through this together. The first thing we have to do is figure out which node type(s) we should target in the visitor. Thankfully, there's a dedicated node type specifically for the `debugger` statement we're interested in:

<EmbeddedSandbox
  initialCode={`const a = b
debugger`}
  depth={2}
  hideDetailView
/>

So we can target that in our visitor:

```js
export default ({ types: t }) => {
  return {
    visitor: {
      DebuggerStatement(path) {
        /* todo */
      },
    },
  }
}
```

Our next step is to get all the variables in scope. As I mentioned in the hint, Babel makes this really easy using the `getAllBindings` method. This method returns an object where the keys are the names of the variables in scope, and the values contain metadata about the variables.

For now, we only need the names of the variables so let's start with that:

```js
DebuggerStatement(path) {
  const variables = Object.keys(path.scope.getAllBindings())
}
```

And with that, we're _almost_ done! All that's left is to push these variables to the global `_variables` array. Here's what that code might look like:

<EmbeddedSandbox
  initialCode={`_variables.push({ a })`}
  depth={2}
  hideEditor
  hideDetailView
  getParent={(tree) => tree?.program?.body[0].expression}
/>

This is where the docs come in handy since we're going to be using quite a few builder functions to construct this node. Since most of this process is going back and forth between the docs and the code, I'll skip to the end result:

```js
/* Builds the _variables.push({ ... }) call */
function createSnapshot(t, scope) {
  return t.expressionStatement(
    t.callExpression(
      t.memberExpression(t.identifier('_variables'), t.identifier('push')),
      [createObjectExpression(t, scope)]
    )
  )
}

/* Builds the object expression { ... } */
function createObjectExpression(t, variables) {
  return t.objectExpression(
    variables.map((variableName) =>
      t.objectProperty(t.identifier(variableName), t.identifier(variableName))
    )
  )
}
```

I broke down the builders into two distinct sections — the call expression itself, and the object expression passed as an argument. The first function, the `createSnapshot` function, deals with building the call expression. In particular, it's building this part of the AST:

<EmbeddedSandbox
  initialCode={`_variables.push(/* todo */)`}
  depth={2}
  hideEditor
  hideDetailView
  getParent={(tree) => tree?.program?.body[0].expression}
/>

The second function, the `createObjectExpression`, builds the object passed in as the argument to the `push` call:

<EmbeddedSandbox
  initialCode={`_variables.push({ a })`}
  depth={2}
  hideEditor
  hideDetailView
  getParent={(tree) => tree?.program?.body[0].expression.arguments[0]}
/>

Finally, all that's left is to replace the `debugger` statement with this new node:

```js
DebuggerStatement(path) {
  const variables = Object.keys(path.scope.getAllBindings())
  path.replaceWith(createSnapshot(t, variables))
}
```

Putting everything together, we get the final result:

<VisitorSandbox
  initialCode={`function sum(arr) {
  let sum = 0
  for (const num of arr) {
    debugger
    sum += num
  }
  return sum
}`}
  visitor={`export default ({ types: t }) => {
  return {
    visitor: {
      DebuggerStatement(path) {
        const variables = Object.keys(path.scope.getAllBindings())
        path.replaceWith(createSnapshot(t, variables))
      },
    },
  }
}
  
/* Builds the _variables.push({ ... }) call */ 
function createSnapshot(t, scope) {
  return t.expressionStatement(
    t.callExpression(
      t.memberExpression(
        t.identifier('_variables'), 
        t.identifier('push')
      ),
      [createObjectExpression(t, scope)]
    )
  )
}
 
/* Builds the object expression { ... } */
function createObjectExpression(t, variables) {
  return t.objectExpression(
    variables.map((variableName) =>
      t.objectProperty(
        t.identifier(variableName), 
        t.identifier(variableName)
      )
    )
  )
}`}
/>

## Edge Cases

A big part in building your own Babel plugin is handling edge cases. After all, there's so many ways of writing code — you're bound to miss something on your first try!

In the visitor we just wrote, we missed one pretty big edge case. Can you spot it? Here's a hint: what happens if you add a `debugger` statement _before_ you declare a variable?

<EmbeddedTranspiler
  initialCode={`const a = 10
debugger
const b = 20`}
/>

Taking a look at the output code, our transpiled code is referring to `b` before it's been declared! If we try to run this code, we're going to get a runtime error. Unfortunately, we can't ask Babel to help us here since it doesn't have any APIs to detect whether a variable has been declared or not.

Talking about how to solve this particular edge case is a bit out of scope of this post, but if you're interested you can take a look at the [actual plugin code used in Playground](https://github.com/narendrasss/playground/blob/master/src/lib/transform/visitor.js). In short, I had to keep track of the variables declared so far and filter out all the variables that weren't declared when replacing the `debugger` statement.

## Applications

If you've written code for the web before you've probably used or heard of [eslint](https://eslint.org/) and [prettier](https://prettier.io/) before. For those of you who haven't, these tools let you lint and format your code so that it's more readable and adheres to best practices.

What's cool about these tools is that they're implemented using the exact same principles of visitors and ASTs that we've worked on throughout this post! Take eslint for example. Like Babel, eslint lets you write your own plugin through their rules API. If you take a look at the source code for a rule, you'll find that [rules are essentially visitors themselves](https://github.com/eslint/eslint/blob/07d14c304c358fbc9c3d318e1377d2b2bda9179f/lib/rules/camelcase.js#L213-L322), just like the one we wrote in the last section.

I think the most important use case of ASTs is one that we, as programmers, probably use on a daily basis without thinking — compilers and interpreters. These tools take human-readable code like JavaScript, and turns them (through ASTs!) to machine code, a low level language understandable by our computers.

Thanks for reading!
