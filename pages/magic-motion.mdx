---
title: "Inside Framer's Magic Motion"
blurb: "A guide on recreating framer's magical layout animations."
description: "A guide on recreating framer's magical layout animations."
publishedAt: '2022-04-07'
editedAt: '2022-04-15'
---

import Callout from '@/elements/Callout'
import { First, Last, Invert, ReactFlip } from '@/components/magic-motion/Flip'
import { Quiz } from '@/components/magic-motion/Quiz'

By far my favourite part about Framer Motion is its seemingly-magical layout animation API. Just slap on the `layout` prop to a motion component and that component will seamlessly animate from one position on the page to the next:

I really like digging into how "magical" things work, so naturally I sought out to figure out how these layout animations work under the hood. This post will cover everything that I learned reimplementing the layout API from scratch.

Let's get started!

<Callout label="Intended Audience">

I try to word my posts to cater to readers of all skill levels, but I realize this post probably makes more sense if you're somewhat comfortable with React and CSS.

</Callout>

## What We're Making

My goal here is to create a component that accepts a boolean prop called `layout`. When `layout` is `true` and the component changes position on the page, it should seamlessly animate from its old position to the new position.

Ultimately, I'm aiming to have my implementation be visually indistinguishable from the framer motion equivalent:

## Animating Position with FLIP

In our sample animation, notice that there are actually two things changing: (1) the component's **position** and (2) the component's **size**. It turns out that animating size is a tad trickier, so we'll focus on implementing position first.

To implement the position change, we'll use a technique called **FLIP**. FLIP stands for **F**irst, **L**ast, **I**nverse, **P**lay. Before we do any layout changes, we **first** record the `x` and `y` coordinates of the element:

<First />

Then we record the **last** position of the element _after_ the layout change:

<Last />

Using transforms, we **invert** the layout change to make it look like the element is back to its original position:

<Invert />

Finally, we **play** the animation by animating the transforms back to zero:

<First />

## FLIP (But in React)

> Feel free to skip ahead to the [animating size](#animating-size) section if you're not interested in the code implementation.

So what does FLIP look like in React?

### Measuring Layout Changes

The first two steps of FLIP involve recording the position of the element both before and after the layout change. To me, this brings up two questions:

1. How do we measure the position of an element?
2. How do we detect a layout change?

The answer to (1) is thankfully quite simple — we'll use the built-in [`.getBoundingClientRect()`]() method. Given an element, this method returns both the element's `x` and `y` coordinates as well as its `width` and `height` in pixels.

<div>Code sandbox here</div>

What about (2) — detecting layout changes?

I'm going to make the assumption here that layout changes can only happen when the component re-renders. Through this assumption, detecting a layout change turns to detecting _re-renders_. This is much easier because React has a built-in way of doing this — the `useEffect` hook.

```tsx
const Motion = (props) => {
  const ref = React.useRef()

  React.useEffect(() => {
    // measure the element
    const box = ref.current.getBoundingClientRect()
  })
  // omitting the dependency array means the callback
  // runs every render

  return <div ref={ref} {...props} />
}
```

Quick quiz time:

<Quiz
  question="In the code snippet, is `box` referring to the element's position before or after the layout change?"
  answers={[
    {
      label: 'Before the layout change',
      tip: "Not quite! The function passed to useEffect will run after the component rerenders, so we're actually measuring the element after the layout change.",
    },
    {
      label: 'After the layout change',
      tip: "That's right! The function passed to useEffect runs after the render, so we're measuring the element after the layout change has happened.",
      correct: true,
    },
  ]}
/>

This kinda works, but it's recording the position of the box _after_ the layout change, not before! This is not a problem necessarily because we need it to implement FLIP anyway, but it's for sure not what we intended. If `useEffect` runs _after_ the render, how do we record the initial position?

<First />

### The `usePrevious` Trick

To fix this problem, I created a custom hook called `usePrevious` that captures the _last_ value of any stateful value. This is what it looks like:

```tsx
const usePrevious = (value) => {
  const ref = React.useRef(value)

  React.useEffect(() => {
    ref.current = value
  }, [value])

  return ref.current
}
```

This definitely looks like one of those blocks of code that shouldn't work, but it does! After all, isn't `useEffect` supposed to be for **synchronizing** values? Shouldn't `ref.current` always be equal to `value` then?

The key here is that **refs don't cause the component to re-render**. Here's the order that the code runs in:

1. `const ref = React.useRef(value)`
2. `return ref.current`
3. `ref.current = value`

Because assigning to a ref doesn't trigger a render, code (2) doesn't run again like it would if `ref` was stateful. This means that `usePrevious` would always return the value in the previous render!

### Implementing the Helpers

Going back to the `<Motion />` component, we'll use a regular `ref` to record the box's last position and the `usePrevious` trick to record the box's first position:

```tsx
const Motion = (props) => {
  const lastBox = React.useRef()
  const elementRef = React.useRef()

  React.useEffect(() => {
    // if lastBox is null, then we just mounted, so the component hasn't moved yet
    if (!lastBox.current) return

    // measure the final (or current) position of the element
    const currentBox = ref.current.getBoundingClientRect()
    const initialBox = lastBox.current

    if (elementMoved({ from: initialBox, to: currentBox })) {
      // calculate the inverse transform
      const { x, y } = getInverse({ first: initialBox, last: currentBox })

      // apply the transform to the element, making it look like
      // it's in its initial position
      elementRef.current.style.transform = `translate(${x}px, ${y}px)`

      // animate the element into its "real" position
      play({
        element: elementRef.current,
        from: { x, y },
      })
    }

    // update the previous value to the current value
    lastBox.current = currentBox
  })

  return <div ref={elementRef} {...props} />
}
```

For all this to work, we'll still need to implement three helper functions — `elementMoved()`, `getInverse()`, and `play()`:

```tsx highlight=12,14,21-24
const Motion = (props) => {
  const lastBox = React.useRef()
  const elementRef = React.useRef()

  React.useEffect(() => {
    // if lastBox is null, then we just mounted, so the component hasn't moved yet
    if (!lastBox.current) return

    // measure the final (or current) position of the element
    const currentBox = ref.current.getBoundingClientRect()
    const initialBox = lastBox.current

    if (elementMoved({ from: initialBox, to: currentBox })) {
      // calculate the inverse transform
      const { x, y } = getInverse({ first: initialBox, last: currentBox })

      // apply the transform to the element, making it look like
      // it's in its initial position
      elementRef.current.style.transform = `translate(${x}px, ${y}px)`

      // animate the element into its "real" position
      play({
        element: elementRef.current,
        from: { x, y },
      })
    }

    // update the previous value to the current value
    lastBox.current = currentBox
  })

  return <div ref={elementRef} {...props} />
}
```

The first function, `elementMoved()`, checks if the two boxes' `x` and `y` coordinates are different:

```tsx
function elementMoved({ from, to }) {
  const { x: fromX, y: fromY } = from
  const { x, y } = to
  return x !== fromX || y !== fromY
}
```

The second function, `getInverse()`, returns the _difference_ between the two positions:

```tsx
function getInverse({ from, to }) {
  const { x: fromX, y: fromY } = from
  const { x, y } = to

  return {
    x: x - fromX,
    y: y - fromY,
  }
}
```

Finally, the last function `play()` animates the element's `transform` property back to zero. For this, we'll be using the [`animate()` function from Popmotion](https://popmotion.io/#quick-start-animation-animate).

```tsx
import { animate } from 'popmotion'

function play({ element, from }) {
  animate({
    from,
    to: { x: 0, y: 0 },
    onUpdate: ({ x, y }) => {
      element.style.transform = `translate(${x}px, ${y}px)`
    },
    duration: 1500,
  })
}
```

### Putting It Together

And all together now:

<ReactFlip />

## Animating Size

Framer motion also lets you animate changes in **size** too, so let's modify our implementation to support this.

## Correcting Distortions
