---
title: "Inside Framer's Magic Motion"
blurb: "A guide on recreating framer's magical layout animations."
description: "A guide on recreating framer's magical layout animations."
publishedAt: '2022-04-07'
editedAt: '2022-04-15'
---

import Callout from '@/elements/Callout'
import * as Flip from '@/components/magic-motion/Flip'
import { Quiz } from '@/components/magic-motion/Quiz'

By far my favourite part about Framer Motion is its seemingly-magical layout animation API. Just slap on the `layout` prop to a motion component and that component will seamlessly animate from one position on the page to the next:

I really like digging into how "magical" things work, so naturally I sought out to figure out how these layout animations work under the hood. This post will cover everything that I learned reimplementing the layout API from scratch.

Let's get started!

<Callout label="Intended Audience">

I try to word my posts to cater to readers of all skill levels, but I realize this post probably makes more sense if you're somewhat comfortable with React and CSS.

</Callout>

## What We're Making

My goal here is to create a component that accepts a boolean prop called `layout`. When `layout` is `true` and the component changes position on the page, it should seamlessly animate from its old position to the new position.

Ultimately, I'm aiming to have my implementation be visually indistinguishable from the framer motion equivalent:

## Animating Position with FLIP

In our sample animation, notice that there are actually two things changing: (1) the component's **position** and (2) the component's **size**. It turns out that animating size is a tad trickier, so we'll focus on implementing position first.

To implement the position change, we'll use a technique called **FLIP**. FLIP stands for **F**irst, **L**ast, **I**nverse, **P**lay. Before we do any layout changes, we **first** record the `x` and `y` coordinates of the element:

<Flip.First />

Then we record the **last** position of the element _after_ the layout change:

<Flip.Last />

Using transforms, we **invert** the layout change to make it look like the element is back to its original position:

<Flip.Invert />

Finally, we **play** the animation by animating the transforms back to zero:

<Flip.Play />

## FLIP (But in React)

> Feel free to skip ahead to the [animating size](#animating-size) section if you're not interested in the code implementation.

So what does FLIP look like in React?

### Measuring Layout Changes

The first two steps of FLIP involve recording the position of the element both before and after the layout change. To me, this brings up two questions:

1. How do we measure the position of an element?
2. How do we detect a layout change?

The answer to (1) is thankfully quite simple — we'll use the built-in [`.getBoundingClientRect()`]() method. Given an element, this method returns both the element's `x` and `y` coordinates as well as its `width` and `height` in pixels.

<div>Code sandbox here</div>

What about (2) — detecting layout changes?

I'm going to make the assumption here that layout changes can only happen when the component re-renders. Through this assumption, we'll check when a layout change happens whenever the component re-renders. And how do we do something when a component re-renders? Using the `useEffect` hook!

```tsx
const Motion = (props) => {
  const ref = React.useRef()

  React.useEffect(() => {
    // measure the element
    const box = ref.current.getBoundingClientRect()
  })
  // omitting the dependency array means the callback
  // runs every render

  return <div ref={ref} {...props} />
}
```

Quick quiz time:

<Quiz
  question="In the code snippet, is `box` referring to the element's position before or after the layout change?"
  answers={[
    {
      label: 'Before the layout change',
      tip: "Not quite! The function passed to useEffect will run after the component rerenders, so we're actually measuring the element after the layout change.",
    },
    {
      label: 'After the layout change',
      tip: "That's right! The function passed to useEffect runs after the render, so we're measuring the element after the layout change has happened.",
      correct: true,
    },
  ]}
/>

This kinda works, but it's recording the position of the box _after_ the layout change, not before! This is not a problem necessarily because we need it to implement FLIP anyway, but it's for sure not what we intended. If `useEffect` runs _after_ the render, how do we record the initial position?

<Flip.First />

### The `usePrevious` Trick

To fix this problem, I created a custom hook called `usePrevious` that captures the _last_ value of any stateful value. This is what it looks like:

```tsx
const usePrevious = (value) => {
  const ref = React.useRef(value)

  React.useEffect(() => {
    ref.current = value
  }, [value])

  return ref.current
}
```

This definitely looks like one of those blocks of code that shouldn't work, but it does! After all, isn't `useEffect` supposed to be for **synchronizing** values? Shouldn't `ref.current` always be equal to `value` then?

The key here is that **refs don't cause the component to re-render**. Here's the order that the code runs in:

1. `const ref = React.useRef(value)`
2. `return ref.current`
3. `ref.current = value`

Because assigning to a ref doesn't trigger a render, code (2) doesn't run again like it would if `ref` was stateful. This means that `usePrevious` would always return the value in the previous render!

### Implementing the Helpers

Going back to the `<Motion />` component, we'll use a regular `ref` to record the box's last position and the `usePrevious` trick to record the box's first position:

```tsx
const Motion = (props) => {
  const lastBox = React.useRef()
  const elementRef = React.useRef()

  React.useEffect(() => {
    // if lastBox is null, then we just mounted, so the component hasn't moved yet
    if (!lastBox.current) return

    // measure the final (or current) position of the element
    const currentBox = ref.current.getBoundingClientRect()
    const initialBox = lastBox.current

    if (elementMoved({ from: initialBox, to: currentBox })) {
      // calculate the inverse transform
      const { x, y } = getInverse({ first: initialBox, last: currentBox })

      // apply the transform to the element, making it look like
      // it's in its initial position
      elementRef.current.style.transform = `translate(${x}px, ${y}px)`

      // animate the element into its "real" position
      play({
        element: elementRef.current,
        from: { x, y },
      })
    }

    // update the previous value to the current value
    lastBox.current = currentBox
  })

  return <div ref={elementRef} {...props} />
}
```

For all this to work, we'll still need to implement three helper functions — `elementMoved()`, `getInverse()`, and `play()`:

```tsx highlight=12,14,21-24
const Motion = (props) => {
  const lastBox = React.useRef()
  const elementRef = React.useRef()

  React.useEffect(() => {
    // if lastBox is null, then we just mounted, so the component hasn't moved yet
    if (!lastBox.current) return

    // measure the final (or current) position of the element
    const currentBox = ref.current.getBoundingClientRect()
    const initialBox = lastBox.current

    if (elementMoved({ from: initialBox, to: currentBox })) {
      // calculate the inverse transform
      const { x, y } = getInverse({ first: initialBox, last: currentBox })

      // apply the transform to the element, making it look like
      // it's in its initial position
      elementRef.current.style.transform = `translate(${x}px, ${y}px)`

      // animate the element into its "real" position
      play({
        element: elementRef.current,
        from: { x, y },
      })
    }

    // update the previous value to the current value
    lastBox.current = currentBox
  })

  return <div ref={elementRef} {...props} />
}
```

The first function, `elementMoved()`, checks if the two boxes' `x` and `y` coordinates are different:

```tsx
function elementMoved({ from, to }) {
  const { x: fromX, y: fromY } = from
  const { x, y } = to
  return x !== fromX || y !== fromY
}
```

The second function, `getInverse()`, returns the _difference_ between the two positions:

```tsx
function getInverse({ from, to }) {
  const { x: fromX, y: fromY } = from
  const { x, y } = to

  return {
    x: x - fromX,
    y: y - fromY,
  }
}
```

Finally, the last function `play()` animates the element's `transform` property back to zero. For this, we'll be using the [`animate()` function from Popmotion](https://popmotion.io/#quick-start-animation-animate).

```tsx
import { animate } from 'popmotion'

function play({ element, from }) {
  animate({
    from,
    to: { x: 0, y: 0 },
    onUpdate: ({ x, y }) => {
      element.style.transform = `translate(${x}px, ${y}px)`
    },
    duration: 1500,
  })
}
```

### Putting It Together

And all together now:

<Flip.ReactFlip />

## Animating Size

Framer motion not only lets you animate changes in position, it lets you animate changes in **size** too. How do we change our implementation to support this?

When I tried implementing this, the first thing that I did was to use the same approach as position - except I would use the `width` and `height` instead of the `x` and `y` coordinates:

```ts
const {
  x,
  y,
  width: scaleX,
  height: scaleY,
} = getInverse({
  first: initialBox,
  last: currentBox,
})
```

Then use `scaleX()` and `scaleY()` to transform the element back to its initial size:

```ts
applyTransform({
  element: elementRef.current,
  transform: { x, y, scaleX, scaleY },
})
```

And finally animate the `scale` back to zero:

```ts
play({
  element: elementRef.current,
  from: { x, y, scaleX, scaleY },
})
```

Should work, right? Well, let's try it and see:

Great! Now what if we animate it with position?

Hmm, _not_ so great. What happened?

### Working Together With Position

When an element changes size, the distance that it travels would change as well.

- The animation should convey this relationship

This little bug is happening because our invert algorithm is coming up a little short from where the element used to be:

- Something that shows the algorithm coming up a little short

To get this to work right, we need to make sure that our algorithm takes into account any changes in size as well. But, how do we change it?

<Quiz
  question="After the layout change, our element is now twice the size it used to be. How do we change the distance travelled so that it shows up back in its original position?"
  answers={[
    {
      label: 'Increase it by width / 2',
      tip: "Not quite! The function passed to useEffect will run after the component rerenders, so we're actually measuring the element after the layout change.",
    },
    {
      label: 'Decrease it by width / 2',
      tip: "That's right! The function passed to useEffect runs after the render, so we're measuring the element after the layout change has happened.",
      correct: true,
    },
  ]}
/>

Specifically, we need to change the _horizontal_ distance travelled by `(oldWidth - newWidth) / 2` and the _vertical_ distance travelled by `(oldHeight - newHeight) / 2`.

<Callout>

There's actually a _tad_ more nuance than that. The change in distance also depends on the element's **transform origin** — but that's a whole rabbit hole that we won't get to. In this post, we'll assume that the transform origin will _always_ be at the center of the element.

</Callout>

## Correcting Distortions

Size animations also leads to another problem: **child element distortion**. Animating size changes using `scale()` is great until you have some text that you want to keep legible at all times:

- animation here showcasing distortion

The trick here is to apply a transform to the child element so that it cancels out the transform that's on the parent:

- animation showing transform cancelling out

### Implementing in React

What does that look like in React?

First, the chid element needs to know about what transform is being applied to the parent component. One way to do this is to have the parent render a React `Context` and set its value to the transform when it's about to animate:

```tsx
<div>
  <MotionContext.Provider value={{ transform }}>
    {children}
  </MotionContext.Provider>
</div>
```

The child element then reads from that context and, if the transform exists, calculates and applies an "inverse transform". We wrap this inside a `useEffect` with no dependency array because the parent can only start animating every render.

```tsx

```

## Summary

Framer motion's magical layout animations are powered by the FLIP technique — a clever way to implement performant layout animations. While implementing FLIP with position changes turned out to be pretty straightforward, the same can't be said for changes in size. When we put size into the picture, we have to worry about:

- How a change in size affects the distance the element travelled;
- Correcting distortions in child elements caused by transforms in the parent element;

And a whole slew of edge cases that I didn't quite get into in this post. That's all for today, thanks for reading!
