---
title: 'How do arrays work?'
blurb: "Rebuilding the world's most popular data structure."
description: 'What goes on under the hood of the most popular data structure? In this post, we uncover the secrets of the array by reinventing one ourselves.'
publishedAt: '2021-06-21'
editedAt: '2021-06-21'
---

import Callout from '@/elements/Callout'
import Placeholder from '@/components/utils/Placeholder'

import IndexLookup from '@/components/how-arrays-work/IndexLookup'
import { MemoryStructure } from '@/components/how-arrays-work/MemoryStructure'
import { MemoryAllocation } from '@/components/how-arrays-work/MemoryAllocation'
import { MemoryReadWrite } from '@/components/how-arrays-work/MemoryReadWrite'
import { MemoryWorkflow } from '@/components/how-arrays-work/MemoryWorkflow'
import Figure from '@/elements/Figure'

The simple array is probably the most popular data structure in programming. It's a straightforward yet powerful tool — it lets you represent an ordered list of items with fast _random_ access. It doesn't matter if you're looking for index 1 or index 500 — with the array, both accesses takes the same amount of time.

<Figure>
  <IndexLookup />
</Figure>

If you've been a developer for a while, you probaby use arrays on a daily basis without thinking too much about them. But have you ever wondered how arrays actually work?

In this post, I want to dive into the technical details of the array and figure out how you might invent the array yourself. We're going to start with a simple array that only supports numbers, then later build that up to the flexible, dynamic array we all know and love from JavaScript.

Let's get started!

## Memory API

Before we start on our array, let's talk about the tools we're going to use to do it. In particular, we're going to be using a virtual memory system that mimics the behaviour of your computer's local memory.

Through the virtual memory system, we're going to have access to the following four methods:

1. `get(address: number)` — returns the value at a specific memory address.
2. `set(address: number, value: number)` — sets the given address to the given value.
3. `allocate(bytes: number)` — allocates a given number of bytes, returning a pointer to the _first_ allocated byte.
4. `free(pointer: Pointer)` — frees the memory location pointed to by the pointer.

If you've written code in a lower level language before, some of these methods might be familiar to you; if not, that's okay too — we'll go over how everything works in this section.

### Reading, Writing, and Addresses

As a starting point, you can think of memory as itself a super long array, where each element of the array represents a single byte:

<Figure>
  <MemoryStructure />
</Figure>

Just like arrays, you can use the index to quickly read and write to a specific location in memory. However, when we're talking about memory in particular, we refer to the index of any individual byte as its _address_.

### Memory Allocation

One key restriction behind our computer's memory system is that you can't freely read and write to any old address in memory\*. In fact, when you begin, you can't read and write to any address at all!

> \*And for good reason too — your computer memory is shared between the hundreds of different programs that are running at the same time. Imagine if programs are able to change memory that's being used by other programs!

To get past this restriction, you have to ask for space in memory by _allocating_ it. To allocate space, you use the `allocate` function, passing in the specific number of bytes that you need:

<Figure>
  <MemoryAllocation size={4} startIndex={1} />
</Figure>

The `allocate` call returns the address of the _first_ byte of the allocated block. In this case, the call returns the address `1` because our 4 byte block begins at address `1`.

> I lied a bit there - the allocate call actually returns a **pointer**, which is functionally equivalent to a memory address but has some additional metadata about the block that was allocated. For this article, understanding that allocation returns "something like" a memory address will suffice.

Great! Now that we have our allocated slice of memory, we can read and write from it as we please:

<Figure>
  <MemoryReadWrite />
</Figure>

Notice how we weren't allowed to write to `block + 4` - that's because we only allocated 4 bytes, so the fifth byte, `block + 4`, is out of bounds!

### Freeing Up Space

Finally, once you're done with the data and don't need it anymore, you can free up that space so the computer can use the memory for other things:

```js
const pointer = Mem.allocate(/* num of bytes */ 12)

// do stuff

Mem.free(pointer)
```

<Callout label="Do we really have to do this?">

If you feel like this is really tedious, that's because it is. Bugs related to memory management happens _all the time_ when writing in lower level languages. Thankfully, JavaScript automates this memory management process for you, allowing you to focus on actually writing code instead of haggling with memory.

</Callout>

One thing you might notice from this allocate-free workflow is that you end up not referencing addresses directly. You just need to work with pointers and move them around. Overall, the typical memory management workflow looks like this:

<Figure>
  <MemoryWorkflow />
</Figure>

As a quick summary:

- Memory, for our purposes, is a long array of bytes where each byte has an associated address
- To use memory, you need to allocate it first; this allocation process returns a pointer, the address of the first byte that you allocated
- Once allocated, you can freely read and write to that memory location
- When you're done, you can free the allocated space so it can be used elsewhere

## Building the Array

That's enough on memory — let's get on with our array! We'll start with a few assumptions to make our lives easier:

1. The array has a fixed length (i.e. it cannot grow in size), and
2. The array can only contain numbers.

These assumptions may seem really restrictive, but don't worry — we'll ease them as we move on.

### Allocating Space

With these assumptions, how would we lay out the array in memory? The simplest way would be to lay out the array as one big continuous block:

<Placeholder name="array block" />

This works for now, so let's see how we can use the memory API we described earlier to make it happen. Remember that the first thing we have to do is to allocate space for it first. To allocate space, we need to know how many bytes we need:

```js
const data = Mem.allocate(/* num of bytes */ ???)
```

Since our array is a fixed length and can only contain numbers, we can determine the total number of bytes we need by multiplying the desired length with the number of bytes for 1 number:

```
total # of bytes = length * (# of bytes for 1 number)
```

In JavaScript, numbers are 8 bytes in size, so we'll use 8 for the number of bytes for 1 number. This gives the total space needed as 8 multiplied by the length of the array:

```js
const SIZE_OF_NUMBER = 8

function createArray(length) {
  const totalSize = length * SIZE_OF_NUMBER
  const array = Mem.allocate(totalSize)

  return {
    get(index) {
      // TODO
    },
    set(index, value) {
      // TODO
    },
  }
}
```

<Placeholder name="allocate array" />

### Reading and Writing

Next, let's implement the `get` and `set` functions. We want to use them like so:

```js
arr.set(/* index */ 0, /* value */ 2)
const item = arr.get(/* index */ 0) // item = 2
```

To implement this, we need to keep two things in mind:

1. As long as you have the address, you can quickly read and write to and from memory
2. Allocating the array gives us the address for the _first_ byte we allocated

To quickly get the item at a particular index, we need to determine the address of the item at that index. How can we determine the address given the address of the first byte only?

For index 0, we already have the address — it's exactly the address that was returned from the allocate function!

<Placeholder name="read index 0" />

For other indices, we have to do a bit of math. Since we know the size of each item in the array, the address of the item at index `i` is:

```
address of index i = address at index 0 + (size of item * i)
```

In our case, the size of each item is the size of a number, 8 bytes. So our formula is then:

```
address of index i = address at index 0 + (8 * i)
```

<Placeholder name="read from index i" />

And this is why arrays are fast! Using the index, we can derive the address that we need without needing to go through every element of the array.

## Growing the Array

So far, our array is static. We define a capacity when we created it, but it can never exceed that initial capacity. Now, let's ease one of our assumptions and let the array grow in size. In particular, we want to implement a `push` function that would add items to the end of the array. How would we change our array to support this?

If our array's length is less than the initial capacity, we don't have to change anything. In this case, all we have to do to add an item is:

1. Calculate the address using the array's length as the new index
2. Store the value to that address

But what if we're at capacity? How do we grow the array then?

### Increasing Capacity

Recall that the memory gates won't let you write to memory that you haven't allocated yet. So naturally, we would have to allocate more memory.

One thing we might be tempted to do would be to allocate just enough memory for the new item. If we're adding a number for example, then we would allocate an extra 8 bytes:

```js
const newAddress = Mem.allocate(/* num of bytes */ 8)
```

This would work just fine if the array was the _only_ thing in memory because then there's always going to be space right next to the array:

<Placeholder name="array in a vacuum" />

In practice though, arrays don't live in a vacuum. You can never be sure how much memory remains and where empty memory lies. It's totally possible that the space around the array is occupied by something else:

<Placeholder name="constrained array" />

Ultimately, the only slice of memory that you are sure of is the part that you've allocated yourself.

Instead, we have to re-allocate space for the entire array _plus_ the element that we're adding. Then, we copy the array into the new space and free up the old memory location:

<Placeholder name="increasing array capacity" />

## Mixing Types

Nice! We now have an array that can grow in size. We still have one more assumption though — our array can only contain the same type of data. We know that in JavaScript this isn't true; you can freely mix and match types without any problems!

### The Problem

Before we look into implementing this in our array, let's see _why_ this assumption was there in the first place. Let's say that we did allow our array to contain multiple types, and all we did to support that was to lay out the items one after another like we've always done:

<Placeholder name="mixing array type memory" />

Now, let's say we want to read an element from the array using its index. First, we need to get the address of that element. Easy enough, we'll use the formula that we wrote down before:

```
address of index i = address at index 0 + (size of item * i)
```

But, um, wait a minute. What's the `size of item`? Now that our elements are of different types, the size (number of bytes) of each item may not necessarily be the same. Uh oh, our formula breaks down, and _we can't quickly determine the address any more_!

<Placeholder name="array element different size" />

### Boxing our Items

In order to make our formula work, we would need to make each element of the array take up the same space in memory despite being different types. How do we do this?

One approach is to "box" the items in our array, wrapping each element in a container of a fixed size:

<Placeholder name="element container" />

The container will contain our value and a tag that indicates what type that value is. The size (in bytes) of our container will then be the size of the tag plus the size of the _largest_ value our container can hold. Since we're working with JavaScript's type system here, this size will be 8 bytes.

Regardless of how large our container is, boxing each element ensures that each element of the array is the same size regardless of its type. This lets us maintain our array's lookup performance.
