---
title: 'How do arrays work?'
blurb: "Rebuilding the world's most popular data structure."
description: 'What goes on under the hood of the most popular data structure? In this post, we uncover the secrets of the array by reinventing one ourselves.'
publishedAt: '2021-11-02'
editedAt: '2021-11-02'
---

import Callout from '@/elements/Callout'
import ProblemStatement from '@/elements/ProblemStatement'
import Placeholder from '@/components/utils/Placeholder'

import IndexLookup from '@/components/how-arrays-work/IndexLookup'
import { MemoryStructure } from '@/components/how-arrays-work/MemoryStructure'
import { MemoryAllocation } from '@/components/how-arrays-work/MemoryAllocation'
import { MemoryReadWrite } from '@/components/how-arrays-work/MemoryReadWrite'
import { MemoryWorkflow } from '@/components/how-arrays-work/MemoryWorkflow'
import { ArrayResize } from '@/components/how-arrays-work/ArrayResize'
import Figure from '@/elements/Figure'

The simple array is probably the most popular data structure in programming. It's a straightforward yet powerful tool — it lets you represent an ordered list of items with fast _random_ access. It doesn't matter if you're looking for index 1 or index 500 — with the array, both accesses takes the same amount of time.

<Figure>
  <IndexLookup />
</Figure>

If you've been a developer for a while, you probaby use arrays on a daily basis without thinking too much about them. But have you ever wondered how arrays actually work?

In this post, I want to dive into the technical details of the array and figure out how you might invent the array yourself. We're going to start with a simple array that only supports numbers, then later build that up to the flexible, dynamic array we all know and love from JavaScript.

Let's get started!

## Memory API

Before we start on our array, let's talk about the tools we're going to use to do it. In particular, we're going to be using a virtual memory system that mimics the behaviour of your computer's local memory.

Through the virtual memory system, we're going to have access to the following four methods:

1. `get(address: number)` — returns the value at a specific memory address.
2. `set(address: number, value: number)` — sets the given address to the given value.
3. `allocate(bytes: number)` — allocates a given number of bytes, returning a pointer to the _first_ allocated byte.
4. `free(pointer: Pointer)` — frees the memory location pointed to by the pointer.

If you've written code in a lower level language before, some of these methods might be familiar to you; if not, that's okay too — we'll go over how everything works in this section.

### Reading, Writing, and Addresses

As a starting point, you can think of memory as itself a super long array, where each element of the array represents a single byte:

<Figure>
  <MemoryStructure />
</Figure>

Just like arrays, you can use the index to quickly read and write to a specific location in memory. However, when we're talking about memory in particular, we refer to the index of any individual byte as its _address_.

### Memory Allocation

One key restriction behind our computer's memory system is that you can't freely read and write to any old address in memory\*. In fact, when you begin, you can't read and write to any address at all!

> \*And for good reason too — your computer memory is shared between the hundreds of different programs that are running at the same time. Imagine if programs are able to change memory that's being used by other programs!

To get past this restriction, you have to ask for space in memory by _allocating_ it. To allocate space, you use the `allocate` function, passing in the specific number of bytes that you need:

<Figure>
  <MemoryAllocation size={4} startIndex={1} />
</Figure>

The `allocate` call returns the address of the _first_ byte of the allocated block. In this case, the call returns the address `1` because our 4 byte block begins at address `1`.

> I lied a bit there - the allocate call actually returns a **pointer**, which is functionally equivalent to a memory address but has some additional metadata about the block that was allocated. For this article, understanding that allocation returns "something like" a memory address will suffice.

Great! Now that we have our allocated slice of memory, we can read and write from it as we please:

<Figure size="lg">
  <MemoryReadWrite />
</Figure>

Notice how we weren't allowed to write to `block + 2` - that's because we only allocated 2 bytes, so the third byte, `block + 2`, is out of bounds!

### Freeing Up Space

Finally, once you're done with the data and don't need it anymore, you can free up that space so the computer can use the memory for other things:

```js
const pointer = Mem.allocate(/* num of bytes */ 12)

// do stuff

Mem.free(pointer)
```

<Callout label="Do we really have to do this?">

If you feel like this is really tedious, that's because it is. Bugs related to memory management happens _all the time_ when writing in lower level languages. Thankfully, JavaScript automates this memory management process for you, allowing you to focus on actually writing code instead of haggling with memory.

</Callout>

One thing you might notice from this allocate-free workflow is that you end up not referencing addresses directly. You just need to work with pointers and move them around. Overall, the typical memory management workflow looks like this:

<Figure size="lg">
  <MemoryWorkflow />
</Figure>

As a quick summary:

- Memory, for our purposes, is a long array of bytes where each byte has an associated address
- To use memory, you need to allocate it first; this allocation process returns a pointer, the address of the first byte that you allocated
- Once allocated, you can freely read and write to that memory location
- When you're done, you can free the allocated space so it can be used elsewhere

## Building the Array

That's enough on memory — let's get on with our array! We'll start with a few assumptions to make our lives easier:

1. The array has a fixed length (i.e. it cannot grow in size), and
2. The array can only contain numbers.

These assumptions may seem really restrictive, but don't worry — we'll ease them as we move on.

### Allocating Space

The first thing that we need to do is allocate space for our array. But, how _much_ space?

```js
const data = Mem.allocate(/* num of bytes */ ???)
```

Thankfully, our assumptions let us determine the size of our array ahead of time. Since our array is a fixed length and can only contain numbers, the total number of bytes we need to allocate is:

```
total # of bytes = length * (# of bytes for 1 number)
```

For the number of bytes for 1 number, we'll use [JavaScript's size of 8 bytes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number). This means that if we want to allocate an array of 10 numbers, we would need to allocate 10 \* 8 = 80 bytes in total.

Awesome, let's code that up:

```js
const SIZE_OF_NUMBER = 8

function array(length) {
  const data = Mem.allocate(length * SIZE_OF_NUMBER)

  return {
    get(index) {
      // TODO
    },
    set(index, value) {
      // TODO
    },
  }
}
```

Let's also add a `free` method to free up any memory used by the array when the user is done with it (recall the memory workflow from the previous section!):

```js highlight=12-14
const SIZE_OF_NUMBER = 8

function array(length) {
  const data = Mem.allocate(length * SIZE_OF_NUMBER)

  return {
    get(index) {
      // TODO
    },
    set(index, value) {
      // TODO
    },
    free() {
      Mem.free(data)
    },
  }
}
```

### Reading and Writing

Next up, we'll need to implement the reading and writing operations so our array is actually usable:

```js
arr.set(/* index */ 0, /* value */ 2)
const item = arr.get(/* index */ 0) // item = 2
```

Remember that the core property of the array is **fast random access**. This means retrieving the element at index 500 should take as long as retrieving the element at index 1. This leads us to our problem:

<ProblemStatement>

How do we quickly retrieve the element at any arbitrary index?

</ProblemStatement>

The hint here is that, given an address, your computer's memory is able to quickly fetch the item at that address. If we're able to efficiently translate an index to a memory address, we'll be able to quickly retrieve the element located there.

Let's work through this using an example. Say we have an array with three numbers, each 2 bytes large:

![](/array_indexing.png)

Using only the address of the _very first byte_, how would we get the address of the element at index 0? What about index 1? Or index 2? Take a look at the diagram above and see if you can find a pattern.

---

We don't need to do any more work for index 0 - the address of the first byte _is_ the address of the first element! But what about the other indices? From the diagram above, we see that the address of the second element (at index 1) is the address of the first byte plus the size of the first element:

![](/array_index_math.png)

Expanding on that further, we find that the address of the second index is the address of the first byte plus _twice_ the size of each element:

![](/array_index_math_two.png)

In general, the address of an element at any index can be determined with the following formula:

```
address = first byte address + (index * size of each element)
```

Using this formula we can go ahead and implement the `get` and `set` functions for our array:

```js highlight=5-8,11-18
const SIZE_OF_NUMBER = 8

function array(length) {
  const data = Mem.allocate(length * SIZE_OF_NUMBER)

  // Helper function to convert an index to an address
  const getAddress = (index) => {
    return data + index * SIZE_OF_NUMBER
  }

  return {
    get(index) {
      const address = getAddress(index)
      return Mem.get(address)
    },
    set(index, value) {
      const address = getAddress(index)
      Mem.set(address, value)
    },
    free() {
      Mem.free(data)
    },
  }
}
```

Something to highlight here is that it doesn't actually matter _what_ type of data the array contains - if every element is the same size, then our formula would work.

So let's update our array to receive the size of each element as a paramater:

```js highlight=0-1,5
function array(length, elementSize) {
  const data = Mem.allocate(length * elementSize)

  // Helper function to convert an index to an address
  const getAddress = index => {
    return data + (index * elementSize))
  }

  return {
    get(index) {
      const address = getAddress(index)
      return Mem.get(address)
    },
    set(index, value) {
      const address = getAddress(index)
      Mem.set(address, value)
    },
    free() {
      Mem.free(data)
    },
  }
}
```

Great work! We now have an array that we can use to represent data. Except, it feels a bit limiting - what if we don't know how many elements we need ahead of time? Or what if we want to store _different_ elements in the same array?

Let's answer these questions one at a time, starting with the former - making the array dynamic.

## Growing the Array

So far, our array is static. We define a length when we create it, but it can never exceed that initial length. This is pretty limiting — what if we _don't_ know how many elements our array will contain? In this section, we'll explore a way to make our array dynamic, making it grow and shrink as the number of items in the array change.

We'll add two new functions to our array's API — `push`, to add elements to the end of the array, and `pop`, to remove elements from the end of the array:

```js
const arr = [1, 2, 3]
arr.push(4) // adds 4 to the end of the array
arr.pop() // returns 4
```

### A First Pass

To start, let's consider the case where our array isn't full yet i.e. the array has less items than the length we initialized it with:

![](array_spare_capacity.png)

When we call `push`, we want to add the value to the end of the array, or index 2 in this case. Because this block was previously allocated, we're good to set the value at this block.

One way we can support this in code is to differentiate between **capacity** and **length**:

- The **capacity** of an array is the number of items it _can_ hold;
- The **length** is the number of items _currently in_ the array.

![](array_capacity_length.png)

The `push` and `pop` functions would use this `length` variable to determine where the end of the array is, then update the variable accordingly:

```js highlight=0-2,20-29
function array(capacity, elementSize) {
  const data = Mem.allocate(capacity * elementSize)
  const length = 0

  const getAddress = index => {
    return data + (index * elementSize))
  }

  return {
    get(index) {
      const address = getAddress(index)
      return Mem.get(address)
    },
    set(index, value) {
      const address = getAddress(index)
      Mem.set(address, value)
    },
    free() {
      Mem.free(data)
    },
    push(value) {
      this.set(length, value)
      length++
    },
    pop(value) {
      if (length > 0) {
        length--
        return this.get(length)
      }
    }
  }
}
```

But what if we're at capacity?

![](array_max_capacity.png)

The end of the array points to an unallocated block, so we can't freely write our value — the memory won't let us. How do we grow our array then?

### Increasing Capacity

Since we need space for more data, our solution is to allocate memory. But, how _much_? One thing we might be tempted to do would be to allocate just enough memory for the new item:

![](allocate_one_block.png)

This would work just fine if the array was the _only_ thing in memory because then there's always going to be space right next to the array. But in practice, arrays don't live in a vacuum. You can never be sure how much memory remains and where empty memory lies. It's totally possible that the space around the array is occupied by something else:

![](memory_filled.png)

This approach also assumes a specific behaviour from the memory allocator. In reality, we can't really be sure _where_ the allocator is going to allocate memory — we can only be sure that the memory that's allocated will be the size we requested it to be.

Since we can't allocate space for only one more element, our alternative is to allocate memory for the whole array _plus_ the new element:

<Figure>
  <ArrayResize slice={[0, 2]} />
</Figure>

Then, we copy the array into the new space:

<Figure>
  <ArrayResize slice={[1, 6]} />
</Figure>

Push the new element into the extra space we now have:

<Figure>
  <ArrayResize slice={[5, 7]} />
</Figure>

And free up the old location:

<Figure>
  <ArrayResize slice={[6, 8]} />
</Figure>

### A Note on Performance

In real code, one `push` call is typically followed by _more_ `push` calls, so it's generally more performant to allocate more than one block of extra space.

<Figure>
  <ArrayResize slice={[0, 2]} performant />
</Figure>

This way, you won't need to resize the array again if you call `push` multiple times:

<Figure>
  <ArrayResize slice={[5, 8]} performant />
</Figure>

## Mixing Types

Great work! So far, we've made an array that:

1. Can quickly find an element given an index
2. Can grow as more items are added to the array

This leaves us with one last assumption — our array can only contain the same type of data. How do we modify our array to handle any kind of data thrown at it?

### The Problem

Before we look into implementing this in our array, let's see _why_ this assumption was there in the first place. Let's say that we did allow our array to contain multiple types, and all we did to support that was to lay out the items one after another like we've always done:

![](/multi-array-naive.png)

Now, let's say we want to get the boolean `true` which is located at index 2. To do this, we would plug in "2" into our address formula:

```
address of index 2 = address at index 0 + (size of item * 2)
```

But, um, wait a minute. What should we put as the "size of item"? Now that our array contains different data types, each element could be a different size. If we put in "2" (using the size of the first element), our formula gives us 4 as the address:

![](/multi-array-broken-formula.png)

Whereas the correct address is 6, since the number "10" takes up 4 bytes of space. Uh oh, our formula doesn't work anymore! This leads us to our problem:

<ProblemStatement>

How do we allow our array to contain data of differing size while still maintaining fast lookup?

</ProblemStatement>

### Boxing Our Items

In order to make our formula work, we would need to make each element of the array take up the same space in memory despite being different types. How do we do this?

One approach is to "box" the items in our array, wrapping each element in a container of a fixed size:

![](/box.png)

The container will contain our value and a tag that indicates what type the box contains. The size (in bytes) of our container will then be the size of the tag plus the size of the **largest** value our container can hold. What the largest value is is typically up to the programming language the array is implemented in. In the case of JavaScript, that size is 8 bytes [citation needed].

Regardless of how large our container is, boxing each element ensures that each element of the array is the same size regardless of its type. This lets us maintain our array's lookup performance.

![](/multi-type-array.png)

Now, if we want to get the element at index 2, we only need to put in the size of our container as the element size.

## Summary

Whew. If you made it all the way here, thank you! I appreciate you. Turns out there's quite a bit happening in the background when we work with arrays. Let's summarize what we've learned:

1. Computer memory is restrictive. You can only use specific bytes by allocating memory first. Because of this, making arrays dynamic is not super straightforward.
2. Array indices get converted to a memory address. This process needs to be fast so that our array can have fast random access.
3. Adding more items to an array might mean we have to resize it under the hood. But as long as we resize correctly, we don't have to resize too often.
4. To make an array handle multiple types, we have to "box" each element in the array so that they take up the same amount of space in memory.

And that's it! Hope you've enjoyed our inventive approach to how arrays work, and thanks again for reading!
