---
title: "Inside Framer's Magic Motion"
blurb: "A guide on recreating framer's magical layout animations."
description: "A guide on recreating framer's magical layout animations."
publishedAt: "2022-04-07"
editedAt: "2022-04-15"
---

import { Callout } from "~/components/Callout";
import { ProblemStatement } from "~/components/ProblemStatement";
import { FullWidth } from "~/components/FullWidth";
import { Caption } from "~/components/Caption";
import { Quiz } from "~/components/Quiz";

import { TokenList } from "../tokenizer/components/TokenList";
import { FlipFirst } from "./components/FlipFirst";
import { FlipLast } from "./components/FlipLast";
import { FlipExample } from "./components/FlipExample";
import { FlipLastReact } from "./components/FlipLastReact";
import { FlipInverse } from "./components/FlipInverse";
import { FlipPlay } from "./components/FlipPlay";
import { FlipOverview } from "./components/FlipOverview";
import { InverseSandbox } from "./components/InverseSandbox";
import { InitialPositionSandbox } from "./components/InitialPositionSandbox";
import { PlaySandbox } from "./components/PlaySandbox";
import { SizeLayoutExample } from "./components/SizeLayoutExample";
import { SizeMeasurements } from "./components/SizeMeasurements";
import { InverseSizeSlider } from "./components/InverseSizeSlider";
import { SizePlayAnimation } from "./components/SizePlayAnimation";
import { SizeDistanceRelationship } from "./components/SizeDistanceRelationship";
import { IncorrectInverseAnimation } from "./components/IncorrectInverseAnimation";

By far my favourite part about Framer Motion is its magical layout animations—slap on the `layout` prop to any motion component, and watch as that component seamlessly transition from one part of the page to the next:

<FullWidth>
  <TokenList type={["single-character"]} toggleable />
  <Caption>
    When you click on "Hide types", the squares seamlessly move from one
    position to the next.
  </Caption>
</FullWidth>

In this post, I want to dive deep into the techniques that allow these layout animations to happen. Specifically, we'll go over concepts like:

1. **FLIP**, the underlying technique that makes layout animations possible;
2. **Animating size** using FLIP and its relationship with position;
3. **Correcting distortions** by applying an inverse scale to all children of animating elements;

Let's get started!

## Introducing FLIP

FLIP, which stands for **F**irst, **L**ast, **I**nverse, **P**lay, is the underlying technique that powers Framer Motion's layout animations. It allows you to emulate changes in "slow" layout properties like `width` and even animate "un-animatable" CSS properties like `justify-content`. Here's how it works.

In the following examples, we'll use FLIP to animate this change in `justify-content` from `flex-start` to `flex-end`:

<FlipExample />

### First

**First**. Before we do the layout change, we record the initial position of the element in terms of `x` and `y` coordinates:

<FlipFirst />

We can do this in code by using a `ref` and the `getBoundingClientRect(){:js}` method:

```tsx {1,5}
const Motion = (props) => {
  const ref = React.useRef();

  React.useEffect(() => {
    const { x, y } = ref.current.getBoundingClientRect();
  }, []);

  return <div ref={ref} {...props} />;
};
```

### Last

**Last**. Then we trigger the layout change and record the position of the square again:

<FlipLast />

To get this working in code, we'll first assume that **a layout change means the component just re-rendered**. So let's start by removing the dependency array from the `useEffect` hook to make the hook run every render.

Try triggering the layout change a few times and check the console to see what `x` and `y` values show up:

<FlipLastReact />

Pop quiz time!

<Quiz label="box-position" answer="final">

<Quiz.Question>
  **After the layout change**, is `box` in the snippet above referring to the
  **initial** position or the **final** position of the square?
</Quiz.Question>

<Quiz.Options>

<Quiz.Option label="initial">
  
The `initial` position

</Quiz.Option>

<Quiz.Option label="final">
  
The `final` position

</Quiz.Option>

</Quiz.Options>

<Quiz.Tip htmlFor="initial">
  Not quite! Because effects run after the component renders, the box is
  actually referring to the square's final position.
</Quiz.Tip>
<Quiz.Tip htmlFor="final">
  That's right! Because effects run after the component renders, the box is
  referring to the square's final position.
</Quiz.Tip>

</Quiz>

If you answered <Quiz.Spoiler htmlFor="box-position">the final position</Quiz.Spoiler>, you'd be right!

This is because **the `useEffect` hook runs after the component renders**. So when we call `getBoundingClientRect(){:js}` in the `useEffect` hook, we're actually getting the position of the square <Quiz.Spoiler htmlFor="box-position">after</Quiz.Spoiler> the layout change.

So how do you get the <Quiz.Spoiler htmlFor="box-position">initial</Quiz.Spoiler> position?

One way is to create a ref (using `useRef`) and store the previous value there every time you measure the box:

<InitialPositionSandbox />

If the flow there doesn't quite make sense, maybe this would help:

```
use effect flow diagram
```

### Inverse

In the **inverse** phase, we modify the position of the square so that it _looks_ like it didn't move at all. To do this, we compare the two measurements we made and calculate a transform that we then apply to the square.

Try moving the slider to adjust the transform applied to the square:

<FlipInverse />

Here's a React implementation of the technique:

<InverseSandbox />

Note that if you press toggle after uncommenting the transform line the square will move out of position. Don't worry too much about it; we'll fix this in the next section!

### Play

So far, we have a square that has a transform applied to it to make it look like it didn't move after toggle is pressed.

In the final step of FLIP, the **Play** step, we animate this transform down to zero to make the square animate to its final position.

<FlipPlay />

There are various ways that you can implement this animation; I personally opted to use the `animate` function from [Popmotion](https://popmotion.io/#quick-start-animation-animate):

<PlaySandbox />

### Putting Everything Together

By doing all of the steps together, we get...

<FlipOverview />

Voila! Magical layout animations.

## Animating Size

So far we've only used FLIP to animate a change in _position_. Can we do the same thing but for _size_? Let's try to replicate the following animation where the square stretches to fill the whole container:

<SizeLayoutExample />

We won't mix changes in position and size together for now; we'll get to that in a bit.

### Measuring Size Changes

We'll start off by measuring the size of the square before and after the layout change. Thankfully, the `.getBoundingClientRect()` method we used to measure the square also happens to return the `width` and `height` of the element:

```ts
const { width, height } = squareRef.current.getBoundingClientRect();
```

<SizeMeasurements />

### Inverting Size Changes

To invert the size change, we'll divide the final size with the initial size:

```ts
const deltaWidth = box.width / initialBoxRef.current.width;
```

This gives us a number that we can pass to `scale`:

```ts
squareRef.current.style.transform = `scaleX(${deltaWidth})`;
```

<InverseSizeSlider />

And instead of animating the scale to zero like we did with position, we'll animate the scale to one (if we animate to zero instead, the element will disappear altogether):

```ts
animate({
  from: deltaWidth,
  to: 1,
  // ...
});
```

<SizePlayAnimation />

### Putting Everything Together

By putting everything together, we get a square that seamlessly transitions between sizes:

```
flip with size
```

## Consolidating Size with Position

Cool! So far we're able to use FLIP to animate changes in position and size. What happens when we try to animate both size _and_ position?

```
broken position and size animation
```

Hmm, that looks a little off. What's going on here? If we break down the animation into its individual steps, we can see that the **inverse** step is the culprit:

```
broken position and size animation inverse
```

The square should line up exactly with its initial position but it's not quite doing that here.

### Size Affects Distance Travelled

Let's try to figure this out.

Here we have two examples. The first compares the distance between the left _edges_ of the squares, while the second compares the distance between the _centers_ of the squares. Use the slider to change the size of the square and try to spot the difference between the two distances:

<SizeDistanceRelationship />

Did you see it?

When the square gets smaller, the distance between the centers is _less_ than the distance between the left edges. But when the square gets bigger, the distance between the centers is _more_ than the distance between the left edges.

The distance between the left edges is what we get when we compare the `x` coordinates of the squares as returned by `.getBoundingClientRect()`. This is how our inverse step works currently. On the other hand, the distance between the centers is what we get when we compare the _transform origins_ of the two squares.

Here's what happens when we invert using the distance between the left edges, as we've been doing so far:

<IncorrectInverseAnimation />

The squares only line up if they're exactly the same size.

But if we use the distance between the centers...

```
corrected animation with centers
```

Would you look at that; it works!

## Correcting Distortions

Size animations also lead to another problem: **child element distortion**. Animating size changes using `scale()` is great until you have some text that you want to keep legible at all times:

<ProblemStatement>
  How do we make sure all child elements stay a uniform size during FLIP?
</ProblemStatement>

### Inverse Scale Formula

For the text to look the same size, we need to apply a scale to the text that "cancels out" the parent's size change. The formula for this scale is:

```
childScaleX = 1 / parentScaleX
```

Intuitively, if the parent gets twice as large, the text needs to be scaled down by half to look the same size.

This animation shows the formula in action. Try moving the slider and notice how the text stays the same size no matter where you drag the slider to:

The next step is to make this work automatically with our layout animations.

### First Attempt

When I was implementing scale correction for the first time, I opted to calculate the inverse scale once at the start of the parent animation.

```ts
/* this runs in the child when the parent is about to animate */
const inverseTransform = {
  scaleX: 1 / parentTransform.scaleX,
  scaleY: 1 / parentTransform.scaleY,
};
play({
  from: inverseTransform,
  to: { scaleX: 1, scaleY: 1 },
});
```

My thinking was that as long as the timing of the scale correction is the same as the parent animation, this approach should work. Except this assumption is flawed:

It turns out the correct approach is to **calculate the inverse scale in every frame of the animation**. But _why_?

### The Scale Curve

Let's try to build this intuition.

Here, we have a square that stretches to 5x its size, at a constant rate, over 5 seconds:

The blue line shows how the `scaleX` property of the square changes throughout the animation. Since we're at the "Play" part of a FLIP animation, the box starts with a `scaleX` of `1/5` (to match its initial position) and slowly works its way to a `scaleX` of `1`.

The text starts off really small because it's being compressed by the parent's `scaleX`. To fix this, we need to apply a `scaleX` to the text that cancels out this effect.

Based on [our formula](#inverse-scale-formula), a `scaleX` value of 5 will correctly cancel out the parent's compression effect:

When the animation starts and 1 second has passed, the square doubles in length, so we need to scale down the text by half to keep it the same size:

After 2 seconds, we need to scale the text down by a third:

After 3 seconds, a quarter:

And so on:

Notice that when we plot these values, they don’t make a straight line!

In comparison, here's what happens when we match the `scaleX` with the parent's timing:

---

What if we now scale back the other way?

Hmm, it's not quite right either. Let's plot the area of the square again:

It's not the same curve! Well, it kinda is, just flipped upside down. If we change the text scale to use _this_ curve now, it looks correct again:

From these examples we can conclude that in order to make the text stay the same size at all times, it needs to counteract its area curve. And the best way to ensure that it does this is to **calculate the transform on every frame of the animation**.

## Summary

Framer motion's magical layout animations are powered by the FLIP technique — a clever way to implement performant layout animations. While implementing FLIP with position changes turned out to be pretty straightforward, the same can't be said for changes in size. When we put size into the picture, we have to worry about:

- How a change in size affects the distance the element travelled;
- Correcting distortions in child elements caused by transforms in the parent element;

And a whole slew of edge cases that I didn't quite get into in this post. That's all for today, thanks for reading!
