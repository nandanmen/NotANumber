---
title: "A Heavy Rectangle Animation"
blurb: "A guide on recreating framer's magical layout animations."
description: "A guide on recreating framer's magical layout animations."
publishedAt: "2023-1-20"
editedAt: "2023-1-20"
---

import { ProblemStatement } from "~/components/ProblemStatement";
import { HeavyRectangleVisualizer } from "./components/HeavyRectangleVisualizer";
import { HorizontalCurve } from "./components/HorizontalCurve";
import { EdgeRotationVisualizer } from "./components/EdgeRotationVisualizer";
import { EdgeRotationProblem } from "./components/EdgeRotationProblem";
import { TrigonometryFunctions } from "./components/TrigonometryFunctions";

I recently made this heavy rectangle animation inspired by [a cool landing page design](https://twitter.com/_justlilian/status/1613549087692824584) I saw on Twitter:

<HeavyRectangleVisualizer />

Under the hood, the rectangle is actually an SVG path that's animated using Framer Motion's motion values. In this post, I'll go over how I made it over three parts:

1. Given a "weight", how do we bend the rectangle down?
2. How do we make the rounded corners?
3. How do we animate the rectangle?

Let's get started!

## SVG Paths

I started off by using SVG paths to create a rectangle:

```
rectangle with paths
```

### On Path Commands

Quick aside here if you're not familiar with SVG paths. `path` elements take a `d` attribute that looks like a string of gibberish but is really a series of **commands**.

Every command relies on a **hidden cursor** to determine where to start drawing. The cursor starts at the origin `(0, 0)` but moves around as commands are executed.

In our case, we're using four different commands to draw our rectangle:

1. `M`, which **moves** the cursor to a specific point
2. `L`, which **draws a line** from the cursor to a specific point
3. `Q`, which **draws a quadratic curve** from the cursor to a specific point, with a control point in between
4. `Z`, which draws a line **from the cursor to the starting point**, closing the path

That's all you need to know for now; you can read more about SVG paths [over on MDN](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).

---

Notice that the horizontal edges are _curves_ instead of straight lines. This way, we can get the "heavy" effect by moving the control points down:

<HorizontalCurve />

Now we _could_ stop here, but it doesn't look quite right — the vertical edges shouldn't stay upright when the rectangle is bending down like that. Instead, the sides should rotate so that they're always perpendicular to the horizontal edges.

## Rotating the Right Corner

Let's focus on the right edge first. When we bend the rectangle down, we want the right edge to rotate such that the angle stays at 90 degrees:

<EdgeRotationVisualizer />

This is harder than it looks — there's no path command to rotate a particular point or line, so we have to calculate the new coordinates of the point ourselves.

<ProblemStatement>

Given the `y` offset of the control point, **what are the coordinates of the end point of the right edge?**

</ProblemStatement>

Or visually:

<EdgeRotationProblem />

### Trigonometry Crash Course

> If you're already familiar with trigonometry, feel free to skip ahead to the next section.

We can solve this problem using the rules of _trigonometry_. If you're unfamiliar, trigonometry describes the relationship between the sides and angles of a triangle.

In particular, it defines the **sine**, **cosine**, and **tangent** functions, which gives us the ratio of any two sides of a right-angle triangle:

<TrigonometryFunctions />

1. `sin(angle)` gives us the ratio between the **opposite** edge and the hypotenuse, i.e. `sin(angle) = length(opposite) / length(hypotenuse)`.
2. `cos(angle)` gives us the ratio between the **adjacent** edge and the hypotenuse, i.e. `cos(angle) = length(adjacent) / length(hypotenuse)`.
3. `tan(angle)` gives us the ratio between the **opposite** edge and the **adjacent** edge, i.e. `tan(angle) = length(opposite) / length(adjacent)`.

The really cool thing is that no matter how large the triangle gets, the `sin`, `cos`, and `tan` functions will **always return the same value for the same angle**. This means that:

1. If you know the length of any two sides, you can calculate the corresponding angle using the _inverse_ trigonometry functions `asin`, `acos`, and `atan`, e.g. `asin(0.5) = 30°`;
2. If you know the angle and the length of one side, you can calculate the length of any of the other sides, e.g. `length(opposite) = length(hypotenuse) * sin(angle)`.

```
some quiz component here?
```

### Calculating the New Coordinates

So how do we apply trigonometry here? Well if we squint a bit, we can see that the rotated right edge is actually a right-angle triangle:

---

So **if we know the angle of the rotation**, we could use the rules of trigonometry to determine the coordinates of the endpoint:

```ts
const getNewCoordinates = (angle: number, height: number) => {
  const x = Math.cos(angle) * height;
  const y = Math.sin(angle) * height;
  return { x, y };
};
```

### Calculating the Angle of Rotation

But how do we know the angle of the rotation? Well, we know that the angle of the right edge is always 90 degrees, so the angle will be the same as this angle:

```
horizontal angle
```

Hey that's another right-angle triangle!

Back in the trigonometry section, we saw that we could calculate the angle of a right-angle triangle if we knew the length of any two sides. In this case, we know the `y` offset and the length of the horizontal edge, so we can calculate the angle using inverse `tan`, `atan`:

```js
const angle = Math.atan(y / (width / 2));
```

In other words, we can calculate the final coordinates using the following function:

```js
const getNewCoordinates = (y: number, width: number, height: number) => {
  const angle = Math.atan(y / (width / 2));
  const x = Math.cos(angle) * height;
  const y = Math.sin(angle) * height;
  return { x, y };
};
```

In this case, `width` and `height` are the width and height of the rectangle, and `y` is how "bent" the rectangle is.

### Constructing the Path

Now that we have this function, we can use it to construct one-half of the rectangle:

```js
const getRectanglePath = (y: number) => {
  // Our rectangle has a width of 80 and a height of 40
  const { x, y } = getNewCoordinates(y, 80, 40);
  return `
    M 0 0
    Q 40 ${y} 40 0
    l ${x} ${y}
  `;
};
```

## Rotating the Left Corner

## Rounding the Corners

## Animating the Rectangle
